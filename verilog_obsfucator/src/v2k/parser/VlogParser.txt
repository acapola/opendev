ANTLR-generated file resulting from grammar Vlog.g
Diagnostic output

Terence Parr, MageLang Institute
with John Lilley, Empathy Software
ANTLR Version 2.7.7 (20080509); 1989-2005

*** Header Action.
This action will appear at the top of all generated files.
	
	/*
	*************************************************************************
	*************************************************************************
	**                                                                     **
	**  V2KPARSE                                                           **
	**  Copyright (C) 2008-2009    Karl W. Pfalzer                         **
	**                                                                     **
	**  This program is free software; you can redistribute it and/or      **
	**  modify it under the terms of the GNU General Public License        **
	**  as published by the Free Software Foundation; either version 2     **
	**  of the License, or (at your option) any later version.             **
	**                                                                     **
	**  This program is distributed in the hope that it will be useful,    **
	**  but WITHOUT ANY WARRANTY; without even the implied warranty of     **
	**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      **
	**  GNU General Public License for more details.                       **
	**                                                                     **
	**  You should have received a copy of the GNU General Public License  **
	**  along with this program; if not, write to the                      **
	**  Free Software Foundation, Inc.                                     **
	**  51 Franklin Street, Fifth Floor                                    **
	**  Boston, MA  02110-1301, USA.                                       **
	**                                                                     **
	*************************************************************************
	*************************************************************************
	*/
	package v2k.parser;
	import  v2k.parser.tree.*;
	
*** End of Header Action


*** Parser Preamble Action.
This action will appear before the declaration of your parser class:
	
*** End of Parser Preamble Action

*** Your parser class is called 'VlogParser' and is a subclass of 'LLkParser'.

*** User-defined parser class members:
These are the member declarations that you defined for your class:
	
	/**Print message unless it was already handled.*/
	public void reportError(RecognitionException ex) {
	if (false == v2k.message.ExceptionBase.class.isInstance(ex)) {
	Message.message(ex);
	}
	}
	
	public void reportError(String s) {
	Message.syntaxError(s);
	}
	
	public void reportWarning(String s) {
			Message.syntaxWarning(s);
	}
	
		static Parser getParser() {
			return Parser.getTheOne();
		}
	
		private static ASTreeBase getTree() {
			return Parser.getTheTree();
		}
	
	
*** End of user-defined parser class members

*** Parser rules:
	
	
	*** Parser Rule: source_text
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ EOF, "module", "macromodule", LPAREN }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ EOF, "module", "macromodule", LPAREN }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ "module", "macromodule", LPAREN }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ "module", "macromodule", LPAREN }
					is matched.
					Rule Reference: description
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match token EOF
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {EOF }
	*** End Parser Rule: source_text
	
	
	*** Parser Rule: description
		Access: public
		Return value: none
		Init action:  ModuleDeclaration mdecl=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "module", "macromodule", LPAREN }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "module", "macromodule", LPAREN }
			is matched.
			Rule Reference: module_declaration, assigned to 'mdecl'
			ACTION: getTree().moduleDeclaration(mdecl);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {EOF, "module", "macromodule", LPAREN }
	*** End Parser Rule: description
	
	
	*** Parser Rule: module_declaration
		Access: public
		Return value(s): ModuleDeclaration mdecl
		Init action: 	mdecl=null; ModuleIdent mid=null; ListOf<ParameterDeclaration> lopd=null;
			ListOf<PortDeclaration> lports=null; 
			NonPortModuleItem npmi=null; ListOf<Port> lop=null;
			ModuleItem mi=null;
			boolean isAnsi=false;
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ "module", "macromodule", LPAREN }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "module", "macromodule", LPAREN }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LPAREN }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LPAREN }
					is matched.
					Rule Reference: attribute_instance
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Rule Reference: module_keyword
			Rule Reference: module_identifier, assigned to 'mid'
			ACTION: getTree().addSymbol(mid);
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ SEMI, POUND, LPAREN }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ POUND }
						is matched.
						Rule Reference: module_parameter_port_list, assigned to 'lopd'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ SEMI, LPAREN }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: mdecl = getTree().moduleDeclaration(mid,lopd);
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {SEMI, LPAREN }
						k==2: {
							"endmodule", LPAREN, RPAREN, COMMA, DOT, 
							LCURLY, "defparam", "localparam", "parameter", "specparam", "integer", 
							"real", "realtime", "time", "inout", "input", "output", 
							"reg", "event", "supply0", "supply1", "tri", "triand", 
							"trior", "tri0", "tri1", "uwire", "wire", "wand", 
							"wor", "function", "task", "generate", "genvar", "for", 
							"if", "case", "assign", "initial", "always", "or", 
							IDENT, ESCAPED_IDENT, "and", "nand", "nor", "xor", 
							"xnor"
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {SEMI, LPAREN }
							k==2: {
								"endmodule", LPAREN, RPAREN, "defparam", "localparam", 
								"parameter", "specparam", "integer", "real", "realtime", "time", 
								"inout", "input", "output", "reg", "event", "supply0", 
								"supply1", "tri", "triand", "trior", "tri0", "tri1", 
								"uwire", "wire", "wand", "wor", "function", "task", 
								"generate", "genvar", "for", "if", "case", "assign", 
								"initial", "always", "or", IDENT, ESCAPED_IDENT, "and", 
								"nand", "nor", "xor", "xnor"
							 }
						is matched, AND the syntactic predicate:
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ LPAREN }
									This block has a single alternative
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LPAREN }
									is matched.
									Start of alternative block.
										Start of an alternative block.
											The lookahead set for this block is:
												{ LPAREN }
											This block has multiple alternatives:
												
												Alternate(1) will be taken IF:
												The lookahead set: 
													{ LPAREN }
												is matched.
												Rule Reference: list_of_port_declarations
												
												Otherwise, Alternate(2) will be taken IF:
												The lookahead set: 
													{  }
												is matched.
												
												OTHERWISE, a NoViableAlt exception will be thrown
												
											End of alternatives
										End of alternative block.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternative block.
						is matched.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ SEMI, LPAREN }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LPAREN }
									is matched.
									Rule Reference: list_of_port_declarations, assigned to 'lports'
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ SEMI }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Match token SEMI
						ACTION: isAnsi=true;
						ACTION: getTree().moduleDeclaration(mdecl,isAnsi,lports);
						Start ZERO-OR-MORE (...)+ block:
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										LPAREN, "defparam", "localparam", "parameter", "specparam", 
										"integer", "real", "realtime", "time", "reg", "event", 
										"supply0", "supply1", "tri", "triand", "trior", "tri0", 
										"tri1", "uwire", "wire", "wand", "wor", "function", 
										"task", "generate", "genvar", "for", "if", "case", 
										"assign", "initial", "always", "or", IDENT, ESCAPED_IDENT, 
										"and", "nand", "nor", "xor", "xnor"
									 }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ 
										LPAREN, "defparam", "localparam", "parameter", "specparam", 
										"integer", "real", "realtime", "time", "reg", "event", 
										"supply0", "supply1", "tri", "triand", "trior", "tri0", 
										"tri1", "uwire", "wire", "wand", "wor", "function", 
										"task", "generate", "genvar", "for", "if", "case", 
										"assign", "initial", "always", "or", IDENT, ESCAPED_IDENT, 
										"and", "nand", "nor", "xor", "xnor"
									 }
								is matched.
								Rule Reference: non_port_module_item, assigned to 'npmi'
								ACTION: getTree().moduleDeclaration(mdecl,npmi);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {LPAREN }
							k==2: {
								RPAREN, COMMA, DOT, LCURLY, IDENT, 
								ESCAPED_IDENT
							 }
						is matched.
						Rule Reference: list_of_ports, assigned to 'lop'
						Match token SEMI
						ACTION: getTree().moduleDeclaration(mdecl,lop);
						Start ZERO-OR-MORE (...)+ block:
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										LPAREN, "defparam", "localparam", "parameter", "specparam", 
										"integer", "real", "realtime", "time", "inout", "input", 
										"output", "reg", "event", "supply0", "supply1", "tri", 
										"triand", "trior", "tri0", "tri1", "uwire", "wire", 
										"wand", "wor", "function", "task", "generate", "genvar", 
										"for", "if", "case", "assign", "initial", "always", 
										"or", IDENT, ESCAPED_IDENT, "and", "nand", "nor", 
										"xor", "xnor"
									 }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ 
										LPAREN, "defparam", "localparam", "parameter", "specparam", 
										"integer", "real", "realtime", "time", "inout", "input", 
										"output", "reg", "event", "supply0", "supply1", "tri", 
										"triand", "trior", "tri0", "tri1", "uwire", "wire", 
										"wand", "wor", "function", "task", "generate", "genvar", 
										"for", "if", "case", "assign", "initial", "always", 
										"or", IDENT, ESCAPED_IDENT, "and", "nand", "nor", 
										"xor", "xnor"
									 }
								is matched.
								Rule Reference: module_item, assigned to 'mi'
								ACTION: getTree().moduleDeclaration(mdecl,mi);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Match string literal "endmodule"
			ACTION: getTree().popScope();
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {EOF, "module", "macromodule", LPAREN }
	*** End Parser Rule: module_declaration
	
	
	*** Parser Rule: attribute_instance
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ LPAREN }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LPAREN }
			is matched.
			Match token LPAREN
			Match token STAR
			Rule Reference: attr_spec
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: attr_spec
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match token STAR
			Match token RPAREN
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, "module", "macromodule", POUND, LPAREN, 
				RPAREN, COMMA, DOT, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"genvar", "for", "if", "case", "begin", "assign", 
				"initial", "always", "deassign", "force", "release", "fork", 
				"repeat", "disable", AT, TRIGGER, "or", "wait", 
				"casex", "casez", "forever", "while", NUMBER, STRING, 
				IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, "and", "nand", "nor", 
				"xor", "xnor", MINUS, PLUS, LNOT, BNOT, 
				BAND, RNAND, BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: attribute_instance
	
	
	*** Parser Rule: module_keyword
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "module", "macromodule" }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ "module" }
				is matched.
				Match string literal "module"
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ "macromodule" }
				is matched.
				Match string literal "macromodule"
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"or", IDENT, ESCAPED_IDENT, "and", "nand", 
				"nor", "xor", "xnor"
			 }
	*** End Parser Rule: module_keyword
	
	
	*** Parser Rule: module_identifier
		Access: public
		Return value(s): ModuleIdent rid
		Init action:  rid=null; Ident id=null; Token la1 = LT(1);
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"or", IDENT, ESCAPED_IDENT, "and", "nand", 
					"nor", "xor", "xnor"
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"or", IDENT, ESCAPED_IDENT, "and", "nand", 
					"nor", "xor", "xnor"
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"or", IDENT, ESCAPED_IDENT, "and", "nand", 
							"nor", "xor", "xnor"
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								"or", "and", "nand", "nor", "xor", 
								"xnor"
							 }
						is matched.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										"or", "and", "nand", "nor", "xor", 
										"xnor"
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "and" }
									is matched.
									Match string literal "and"
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ "nand" }
									is matched.
									Match string literal "nand"
									
									Otherwise, Alternate(3) will be taken IF:
									The lookahead set: 
										{ "nor" }
									is matched.
									Match string literal "nor"
									
									Otherwise, Alternate(4) will be taken IF:
									The lookahead set: 
										{ "or" }
									is matched.
									Match string literal "or"
									
									Otherwise, Alternate(5) will be taken IF:
									The lookahead set: 
										{ "xor" }
									is matched.
									Match string literal "xor"
									
									Otherwise, Alternate(6) will be taken IF:
									The lookahead set: 
										{ "xnor" }
									is matched.
									Match string literal "xnor"
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						ACTION: la1.setType(IDENT); id = new Ident(la1);		
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ IDENT, ESCAPED_IDENT }
						is matched.
						Rule Reference: identifier, assigned to 'id'
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: rid = getTree().moduleIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, POUND, LPAREN, IDENT, ESCAPED_IDENT }
	*** End Parser Rule: module_identifier
	
	
	*** Parser Rule: module_parameter_port_list
		Access: public
		Return value(s): ListOf<ParameterDeclaration> lopd
		Init action:  lopd=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ POUND }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ POUND }
			is matched.
			Match token POUND
			Match token LPAREN
			Rule Reference: parameter_declarations, assigned to 'lopd'
			Match token RPAREN
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, LPAREN }
	*** End Parser Rule: module_parameter_port_list
	
	
	*** Parser Rule: list_of_port_declarations
		Access: public
		Return value(s): ListOf<PortDeclaration> lopd
		Init action:  lopd=null; PortDeclaration pd=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LPAREN }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LPAREN }
			is matched.
			Match token LPAREN
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ LPAREN, RPAREN, "inout", "input", "output" }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LPAREN, "inout", "input", "output" }
						is matched.
						Rule Reference: port_declaration, assigned to 'pd', arguments = true
						ACTION: lopd = getTree().addToList(lopd,pd);
						Start ZERO-OR-MORE (...)+ block:
							Start of an alternative block.
								The lookahead set for this block is:
									{ COMMA }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ COMMA }
								is matched.
								Match token COMMA
								Rule Reference: port_declaration, assigned to 'pd', arguments = true
								ACTION: lopd = getTree().addToList(lopd,pd);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ RPAREN }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Match token RPAREN
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: list_of_port_declarations
	
	
	*** Parser Rule: non_port_module_item
		Access: public
		Return value(s): NonPortModuleItem npmi
		Init action:  npmi=null; Object o1=null;
		Error: This rule is non-deterministic
		Start of an alternative block.
			The lookahead set for this block is:
				k==1: {
					LPAREN, "defparam", "localparam", "parameter", "specparam", 
					"integer", "real", "realtime", "time", "reg", "event", 
					"supply0", "supply1", "tri", "triand", "trior", "tri0", 
					"tri1", "uwire", "wire", "wand", "wor", "function", 
					"task", "generate", "genvar", "for", "if", "case", 
					"assign", "initial", "always", "or", IDENT, ESCAPED_IDENT, 
					"and", "nand", "nor", "xor", "xnor"
				 }
				k==2: {
					POUND, LPAREN, LCURLY, LBRACK, "defparam", 
					"localparam", "signed", "integer", "real", "realtime", "time", 
					"reg", "event", "vectored", "scalared", "supply0", "supply1", 
					"tri", "triand", "trior", "tri0", "tri1", "uwire", 
					"wire", "wand", "wor", "function", "automatic", "task", 
					"endgenerate", "genvar", "for", "if", "case", "begin", 
					"assign", "initial", "always", "deassign", "force", "release", 
					"fork", "repeat", "disable", AT, STAR, TRIGGER, 
					"or", "wait", "casex", "casez", "forever", "while", 
					IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, "and", "nand", "nor", 
					"xor", "xnor"
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					k==1: {
						LPAREN, "defparam", "localparam", "integer", "real", 
						"realtime", "time", "reg", "event", "supply0", "supply1", 
						"tri", "triand", "trior", "tri0", "tri1", "uwire", 
						"wire", "wand", "wor", "function", "task", "genvar", 
						"for", "if", "case", "assign", "initial", "always", 
						"or", IDENT, ESCAPED_IDENT, "and", "nand", "nor", 
						"xor", "xnor"
					 }
					k==2: {
						POUND, LPAREN, LCURLY, LBRACK, "signed", 
						"integer", "real", "realtime", "time", "vectored", "scalared", 
						"automatic", "for", "if", "case", "begin", "assign", 
						"deassign", "force", "release", "fork", "repeat", "disable", 
						AT, STAR, TRIGGER, "wait", "casex", "casez", 
						"forever", "while", IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME
					 }
				is matched, AND the syntactic predicate:
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ 
									LPAREN, "defparam", "localparam", "integer", "real", 
									"realtime", "time", "reg", "event", "supply0", "supply1", 
									"tri", "triand", "trior", "tri0", "tri1", "uwire", 
									"wire", "wand", "wor", "function", "task", "genvar", 
									"for", "if", "case", "assign", "initial", "always", 
									"or", IDENT, ESCAPED_IDENT, "and", "nand", "nor", 
									"xor", "xnor"
								 }
							This block has a single alternative
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ 
									LPAREN, "defparam", "localparam", "integer", "real", 
									"realtime", "time", "reg", "event", "supply0", "supply1", 
									"tri", "triand", "trior", "tri0", "tri1", "uwire", 
									"wire", "wand", "wor", "function", "task", "genvar", 
									"for", "if", "case", "assign", "initial", "always", 
									"or", IDENT, ESCAPED_IDENT, "and", "nand", "nor", 
									"xor", "xnor"
								 }
							is matched.
							Rule Reference: module_or_generate_item
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternative block.
				is matched.
				Rule Reference: module_or_generate_item, assigned to 'o1'
				ACTION: npmi = getTree().nonPortModuleItem((ModuleOrGenerateItem)o1);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ "generate" }
				is matched.
				Rule Reference: generate_region, assigned to 'o1'
				ACTION: npmi = getTree().nonPortModuleItem((ListOf<ModuleOrGenerateItem>)o1);
				
				Otherwise, Alternate(3) will be taken IF:
				The lookahead set: 
					k==1: {LPAREN, "parameter", "specparam" }
					k==2: {
						LBRACK, "signed", "integer", "real", "realtime", 
						"time", STAR, IDENT, ESCAPED_IDENT
					 }
				is matched.
				Start ZERO-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ LPAREN }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LPAREN }
						is matched.
						Rule Reference: attribute_instance
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ZERO-OR-MORE block.
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ "parameter", "specparam" }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ "parameter" }
							is matched.
							Rule Reference: parameter_declaration, assigned to 'o1'
							Match token SEMI
							ACTION: npmi = getTree().nonPortModuleItem((ParameterDeclaration)o1);
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ "specparam" }
							is matched.
							Rule Reference: specparam_declaration, assigned to 'o1'
							ACTION: npmi = getTree().nonPortModuleItem((SpecparamDecl)o1);
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, "defparam", "localparam", "parameter", 
				"specparam", "integer", "real", "realtime", "time", "inout", 
				"input", "output", "reg", "event", "supply0", "supply1", 
				"tri", "triand", "trior", "tri0", "tri1", "uwire", 
				"wire", "wand", "wor", "function", "task", "generate", 
				"genvar", "for", "if", "case", "assign", "initial", 
				"always", "or", IDENT, ESCAPED_IDENT, "and", "nand", 
				"nor", "xor", "xnor"
			 }
	*** End Parser Rule: non_port_module_item
	
	
	*** Parser Rule: list_of_ports
		Access: public
		Return value(s): ListOf<Port> lop
		Init action:  lop=null; Port port=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LPAREN }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LPAREN }
			is matched.
			Match token LPAREN
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {
							RPAREN, COMMA, DOT, LCURLY, IDENT, 
							ESCAPED_IDENT
						 }
						k==2: {
							SEMI, RPAREN, COMMA, DOT, LCURLY, 
							LBRACK, IDENT, ESCAPED_IDENT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {
								RPAREN, COMMA, DOT, LCURLY, IDENT, 
								ESCAPED_IDENT
							 }
							k==2: {
								SEMI, RPAREN, COMMA, DOT, LCURLY, 
								LBRACK, IDENT, ESCAPED_IDENT
							 }
						is matched.
						Rule Reference: port, assigned to 'port'
						ACTION: lop=getTree().addToList(lop,port);
						Start ZERO-OR-MORE (...)+ block:
							Start of an alternative block.
								The lookahead set for this block is:
									{ COMMA }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ COMMA }
								is matched.
								Match token COMMA
								Rule Reference: port, assigned to 'port'
								ACTION: lop=getTree().addToList(lop,port);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {RPAREN }
							k==2: {SEMI }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Match token RPAREN
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: list_of_ports
	
	
	*** Parser Rule: module_item
		Access: public
		Return value(s): ModuleItem mi
		Init action:  mi=null; PortDeclaration pd=null; NonPortModuleItem npi=null;
		Error: This rule is non-deterministic
		Start of an alternative block.
			The lookahead set for this block is:
				k==1: {
					LPAREN, "defparam", "localparam", "parameter", "specparam", 
					"integer", "real", "realtime", "time", "inout", "input", 
					"output", "reg", "event", "supply0", "supply1", "tri", 
					"triand", "trior", "tri0", "tri1", "uwire", "wire", 
					"wand", "wor", "function", "task", "generate", "genvar", 
					"for", "if", "case", "assign", "initial", "always", 
					"or", IDENT, ESCAPED_IDENT, "and", "nand", "nor", 
					"xor", "xnor"
				 }
				k==2: {
					POUND, LPAREN, LCURLY, LBRACK, "defparam", 
					"localparam", "signed", "integer", "real", "realtime", "time", 
					"reg", "event", "vectored", "scalared", "supply0", "supply1", 
					"tri", "triand", "trior", "tri0", "tri1", "uwire", 
					"wire", "wand", "wor", "function", "automatic", "task", 
					"endgenerate", "genvar", "for", "if", "case", "begin", 
					"assign", "initial", "always", "deassign", "force", "release", 
					"fork", "repeat", "disable", AT, STAR, TRIGGER, 
					"or", "wait", "casex", "casez", "forever", "while", 
					IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, "and", "nand", "nor", 
					"xor", "xnor"
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					k==1: {LPAREN, "inout", "input", "output" }
					k==2: {
						LBRACK, "signed", "integer", "time", "reg", 
						"supply0", "supply1", "tri", "triand", "trior", "tri0", 
						"tri1", "uwire", "wire", "wand", "wor", STAR, 
						IDENT, ESCAPED_IDENT
					 }
				is matched, AND the syntactic predicate:
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ LPAREN, "inout", "input", "output" }
							This block has a single alternative
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ LPAREN, "inout", "input", "output" }
							is matched.
							Rule Reference: port_declaration, arguments = false
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternative block.
				is matched.
				Rule Reference: port_declaration, assigned to 'pd', arguments = false
				Match token SEMI
				ACTION: mi = getTree().moduleItem(pd);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					k==1: {
						LPAREN, "defparam", "localparam", "parameter", "specparam", 
						"integer", "real", "realtime", "time", "reg", "event", 
						"supply0", "supply1", "tri", "triand", "trior", "tri0", 
						"tri1", "uwire", "wire", "wand", "wor", "function", 
						"task", "generate", "genvar", "for", "if", "case", 
						"assign", "initial", "always", "or", IDENT, ESCAPED_IDENT, 
						"and", "nand", "nor", "xor", "xnor"
					 }
					k==2: {
						POUND, LPAREN, LCURLY, LBRACK, "defparam", 
						"localparam", "signed", "integer", "real", "realtime", "time", 
						"reg", "event", "vectored", "scalared", "supply0", "supply1", 
						"tri", "triand", "trior", "tri0", "tri1", "uwire", 
						"wire", "wand", "wor", "function", "automatic", "task", 
						"endgenerate", "genvar", "for", "if", "case", "begin", 
						"assign", "initial", "always", "deassign", "force", "release", 
						"fork", "repeat", "disable", AT, STAR, TRIGGER, 
						"or", "wait", "casex", "casez", "forever", "while", 
						IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, "and", "nand", "nor", 
						"xor", "xnor"
					 }
				is matched.
				Rule Reference: non_port_module_item, assigned to 'npi'
				ACTION: mi = getTree().moduleItem(npi);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, "defparam", "localparam", "parameter", 
				"specparam", "integer", "real", "realtime", "time", "inout", 
				"input", "output", "reg", "event", "supply0", "supply1", 
				"tri", "triand", "trior", "tri0", "tri1", "uwire", 
				"wire", "wand", "wor", "function", "task", "generate", 
				"genvar", "for", "if", "case", "assign", "initial", 
				"always", "or", IDENT, ESCAPED_IDENT, "and", "nand", 
				"nor", "xor", "xnor"
			 }
	*** End Parser Rule: module_item
	
	
	*** Parser Rule: parameter_declarations
		Access: public
		Return value(s): ListOf<ParameterDeclaration> lopd
		Init action: lopd=null; ParameterDeclaration pd=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "parameter" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "parameter" }
			is matched.
			Rule Reference: parameter_declaration, assigned to 'pd'
			ACTION: lopd=getTree().addToList(lopd,pd);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: parameter_declaration, assigned to 'pd'
					ACTION: lopd=getTree().addToList(lopd,pd);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN }
	*** End Parser Rule: parameter_declarations
	
	
	*** Parser Rule: parameter_declaration
		Access: public
		Return value(s): ParameterDeclaration pd
		Init action:  pd=null; boolean isSigned=false; Range rng=null; 
		ListOf<ParamAssign> lopa=null; ParameterType pt=null;
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ "parameter" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "parameter" }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {"parameter" }
						k==2: {
							LBRACK, "signed", "integer", "real", "realtime", 
							"time", IDENT, ESCAPED_IDENT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {"parameter" }
							k==2: {LBRACK, "signed", IDENT, ESCAPED_IDENT }
						is matched.
						Match string literal "parameter"
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "signed" }
									is matched.
									Match string literal "signed"
									ACTION: isSigned=true;
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ LBRACK, IDENT, ESCAPED_IDENT }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK, IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LBRACK }
									is matched.
									Rule Reference: range, assigned to 'rng'
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ IDENT, ESCAPED_IDENT }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Rule Reference: list_of_param_assignments, assigned to 'lopa'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {"parameter" }
							k==2: {"integer", "real", "realtime", "time" }
						is matched.
						Match string literal "parameter"
						Rule Reference: parameter_type, assigned to 'pt'
						Rule Reference: list_of_param_assignments, assigned to 'lopa'
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: pd = getTree().parameterDecl(isSigned,rng,pt,lopa);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN, COMMA }
	*** End Parser Rule: parameter_declaration
	
	
	*** Parser Rule: port
		Access: public
		Return value(s): Port port
		Init action:  port=null; PortExpression pexpr=null; PortIdent pid=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					RPAREN, COMMA, DOT, LCURLY, IDENT, 
					ESCAPED_IDENT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					RPAREN, COMMA, DOT, LCURLY, IDENT, 
					ESCAPED_IDENT
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							RPAREN, COMMA, DOT, LCURLY, IDENT, 
							ESCAPED_IDENT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ RPAREN, COMMA, LCURLY, IDENT, ESCAPED_IDENT }
						is matched.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ RPAREN, COMMA, LCURLY, IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LCURLY, IDENT, ESCAPED_IDENT }
									is matched.
									Rule Reference: port_expression, assigned to 'pexpr'
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ RPAREN, COMMA }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ DOT }
						is matched.
						Match token DOT
						Rule Reference: port_identifier, assigned to 'pid'
						Match token LPAREN
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ RPAREN, LCURLY, IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LCURLY, IDENT, ESCAPED_IDENT }
									is matched.
									Rule Reference: port_expression, assigned to 'pexpr'
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ RPAREN }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Match token RPAREN
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: port = getTree().port(pid,pexpr);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN, COMMA }
	*** End Parser Rule: port
	
	
	*** Parser Rule: port_declaration
		Access: public
		Return value(s): PortDeclaration pd
		Arguments: boolean isOnlyDefn
		Init action:  pd=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LPAREN, "inout", "input", "output" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LPAREN, "inout", "input", "output" }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LPAREN }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LPAREN }
					is matched.
					Rule Reference: attribute_instance
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ "inout", "input", "output" }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "inout" }
						is matched.
						Rule Reference: inout_declaration, assigned to 'pd', arguments = isOnlyDefn
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "input" }
						is matched.
						Rule Reference: input_declaration, assigned to 'pd', arguments = isOnlyDefn
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ "output" }
						is matched.
						Rule Reference: output_declaration, assigned to 'pd', arguments = isOnlyDefn
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN, COMMA }
	*** End Parser Rule: port_declaration
	
	
	*** Parser Rule: port_expression
		Access: public
		Return value(s): PortExpression pexpr
		Init action:  pexpr=null; PortReference pref=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LCURLY, IDENT, ESCAPED_IDENT }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ IDENT, ESCAPED_IDENT }
				is matched.
				Rule Reference: port_reference, assigned to 'pref'
				ACTION: pexpr = getTree().portExpression(null,pref);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ LCURLY }
				is matched.
				Match token LCURLY
				Rule Reference: port_reference, assigned to 'pref'
				ACTION: pexpr = getTree().portExpression(null,pref);
				Start ZERO-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ COMMA }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ COMMA }
						is matched.
						Match token COMMA
						Rule Reference: port_reference, assigned to 'pref'
						ACTION: getTree().portExpression(pexpr,pref);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ZERO-OR-MORE block.
				Match token RCURLY
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN, COMMA }
	*** End Parser Rule: port_expression
	
	
	*** Parser Rule: port_identifier
		Access: public
		Return value(s): PortIdent rid
		Init action:  rid=null; Ident id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'id'
			ACTION: rid = getTree().portIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, LPAREN, RPAREN, COMMA, RCURLY, 
				LBRACK, ASSIGN
			 }
	*** End Parser Rule: port_identifier
	
	
	*** Parser Rule: port_reference
		Access: public
		Return value(s): PortReference pref
		Init action:  pref=null; PortIdent pid=null; ConstRangeExpression rexpr=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: port_identifier, assigned to 'pid'
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ RPAREN, COMMA, RCURLY, LBRACK }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LBRACK }
						is matched.
						Match token LBRACK
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										LPAREN, LCURLY, RBRACK, NUMBER, STRING, 
										IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, 
										BNOT, BAND, RNAND, BOR, RNOR, BXOR, 
										RXNOR
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ 
											LPAREN, LCURLY, NUMBER, STRING, IDENT, 
											ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
											BAND, RNAND, BOR, RNOR, BXOR, RXNOR
										 }
									is matched.
									Rule Reference: constant_range_expression, assigned to 'rexpr'
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ RBRACK }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Match token RBRACK
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ RPAREN, COMMA, RCURLY }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: pref = getTree().portReference(pid,rexpr);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN, COMMA, RCURLY }
	*** End Parser Rule: port_reference
	
	
	*** Parser Rule: constant_range_expression
		Access: public
		Return value(s): ConstRangeExpression cre
		Init action:  cre=null; ConstExpression ce1=null, ce2=null; int op=-1;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Rule Reference: constant_expression, assigned to 'ce1'
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ RBRACK, COLON, PLUS_COLON, MINUS_COLON }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ COLON, PLUS_COLON, MINUS_COLON }
						is matched.
						ACTION: op=LA(1);
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ COLON, PLUS_COLON, MINUS_COLON }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ PLUS_COLON }
									is matched.
									Match token PLUS_COLON
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ MINUS_COLON }
									is matched.
									Match token MINUS_COLON
									
									Otherwise, Alternate(3) will be taken IF:
									The lookahead set: 
										{ COLON }
									is matched.
									Match token COLON
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Rule Reference: constant_expression, assigned to 'ce2'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ RBRACK }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: cre = getTree().constantRangeExpression(ce1,op,ce2);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RBRACK }
	*** End Parser Rule: constant_range_expression
	
	
	*** Parser Rule: inout_declaration
		Access: public
		Return value(s): PortDeclaration pd
		Arguments: boolean isOnlyDefn
		Init action:  pd=null; int dir=LA(1); NetType type=null; Range rng=null;
		boolean isSigned=false;
		ListOf<? extends PortIdent> ids = null;
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ "inout" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "inout" }
			is matched.
			Match string literal "inout"
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							LBRACK, "signed", "supply0", "supply1", "tri", 
							"triand", "trior", "tri0", "tri1", "uwire", "wire", 
							"wand", "wor", IDENT, ESCAPED_IDENT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								"supply0", "supply1", "tri", "triand", "trior", 
								"tri0", "tri1", "uwire", "wire", "wand", "wor"
							 }
						is matched.
						Rule Reference: net_type, assigned to 'type'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "signed" }
						is matched.
						Match string literal "signed"
						ACTION: isSigned=true;
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ LBRACK, IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ LBRACK, IDENT, ESCAPED_IDENT }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LBRACK }
						is matched.
						Rule Reference: range, assigned to 'rng'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: list_of_port_identifiers, assigned to 'ids'
			ACTION: pd = getTree().portDecl(isOnlyDefn,dir,type,rng,null,false,isSigned,ids);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN, COMMA }
	*** End Parser Rule: inout_declaration
	
	
	*** Parser Rule: input_declaration
		Access: public
		Return value(s): PortDeclaration pd
		Arguments: boolean isOnlyDefn
		Init action:  pd=null; int dir=LA(1); NetType type=null; Range rng=null;
		boolean isSigned=false;
		ListOf<? extends PortIdent> ids = null;
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ "input" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "input" }
			is matched.
			Match string literal "input"
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							LBRACK, "signed", "supply0", "supply1", "tri", 
							"triand", "trior", "tri0", "tri1", "uwire", "wire", 
							"wand", "wor", IDENT, ESCAPED_IDENT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								"supply0", "supply1", "tri", "triand", "trior", 
								"tri0", "tri1", "uwire", "wire", "wand", "wor"
							 }
						is matched.
						Rule Reference: net_type, assigned to 'type'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "signed" }
						is matched.
						Match string literal "signed"
						ACTION: isSigned=true;
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ LBRACK, IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ LBRACK, IDENT, ESCAPED_IDENT }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LBRACK }
						is matched.
						Rule Reference: range, assigned to 'rng'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: list_of_port_identifiers, assigned to 'ids'
			ACTION: pd = getTree().portDecl(isOnlyDefn,dir,type,rng,null,false,isSigned,ids);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN, COMMA }
	*** End Parser Rule: input_declaration
	
	
	*** Parser Rule: output_declaration
		Access: public
		Return value(s): PortDeclaration pd
		Arguments: boolean isOnlyDefn
		Init action:  pd=null; int dir=LA(1); NetType type=null; Range rng=null;
		boolean isReg=false; boolean isSigned=false;
		ListOf<? extends PortIdent> ids = null; OutputVarType ovt=null;
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ "output" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "output" }
			is matched.
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {"output" }
						k==2: {
							LBRACK, "signed", "integer", "time", "reg", 
							"supply0", "supply1", "tri", "triand", "trior", "tri0", 
							"tri1", "uwire", "wire", "wand", "wor", IDENT, 
							ESCAPED_IDENT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {"output" }
							k==2: {"integer", "time" }
						is matched, AND the syntactic predicate:
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ "output" }
									This block has a single alternative
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "output" }
									is matched.
									Match string literal "output"
									Rule Reference: output_variable_type
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternative block.
						is matched.
						Match string literal "output"
						Rule Reference: output_variable_type, assigned to 'ovt'
						Rule Reference: list_of_variable_port_identifiers, assigned to 'ids'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {"output" }
							k==2: {LBRACK, "signed", "reg", IDENT, ESCAPED_IDENT }
						is matched, AND the syntactic predicate:
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ "output" }
									This block has a single alternative
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "output" }
									is matched.
									Match string literal "output"
									Start of alternative block.
										Start of an alternative block.
											The lookahead set for this block is:
												{ LBRACK, "signed", "reg", IDENT, ESCAPED_IDENT }
											This block has multiple alternatives:
												
												Alternate(1) will be taken IF:
												The lookahead set: 
													{ "reg" }
												is matched.
												Match string literal "reg"
												
												Otherwise, Alternate(2) will be taken IF:
												The lookahead set: 
													{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
												is matched.
												
												OTHERWISE, a NoViableAlt exception will be thrown
												
											End of alternatives
										End of alternative block.
									Start of alternative block.
										Start of an alternative block.
											The lookahead set for this block is:
												{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
											This block has multiple alternatives:
												
												Alternate(1) will be taken IF:
												The lookahead set: 
													{ "signed" }
												is matched.
												Match string literal "signed"
												
												Otherwise, Alternate(2) will be taken IF:
												The lookahead set: 
													{ LBRACK, IDENT, ESCAPED_IDENT }
												is matched.
												
												OTHERWISE, a NoViableAlt exception will be thrown
												
											End of alternatives
										End of alternative block.
									Start of alternative block.
										Start of an alternative block.
											The lookahead set for this block is:
												{ LBRACK, IDENT, ESCAPED_IDENT }
											This block has multiple alternatives:
												
												Alternate(1) will be taken IF:
												The lookahead set: 
													{ LBRACK }
												is matched.
												Rule Reference: range
												
												Otherwise, Alternate(2) will be taken IF:
												The lookahead set: 
													{ IDENT, ESCAPED_IDENT }
												is matched.
												
												OTHERWISE, a NoViableAlt exception will be thrown
												
											End of alternatives
										End of alternative block.
									Rule Reference: list_of_variable_port_identifiers
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternative block.
						is matched.
						Match string literal "output"
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK, "signed", "reg", IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "reg" }
									is matched.
									Match string literal "reg"
									ACTION: isReg=true;
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "signed" }
									is matched.
									Match string literal "signed"
									ACTION: isSigned=true;
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ LBRACK, IDENT, ESCAPED_IDENT }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK, IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LBRACK }
									is matched.
									Rule Reference: range, assigned to 'rng'
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ IDENT, ESCAPED_IDENT }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Rule Reference: list_of_variable_port_identifiers, assigned to 'ids'
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							k==1: {"output" }
							k==2: {
								LBRACK, "signed", "supply0", "supply1", "tri", 
								"triand", "trior", "tri0", "tri1", "uwire", "wire", 
								"wand", "wor", IDENT, ESCAPED_IDENT
							 }
						is matched.
						Match string literal "output"
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										LBRACK, "signed", "supply0", "supply1", "tri", 
										"triand", "trior", "tri0", "tri1", "uwire", "wire", 
										"wand", "wor", IDENT, ESCAPED_IDENT
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ 
											"supply0", "supply1", "tri", "triand", "trior", 
											"tri0", "tri1", "uwire", "wire", "wand", "wor"
										 }
									is matched.
									Rule Reference: net_type, assigned to 'type'
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "signed" }
									is matched.
									Match string literal "signed"
									ACTION: isSigned=true;
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ LBRACK, IDENT, ESCAPED_IDENT }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK, IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LBRACK }
									is matched.
									Rule Reference: range, assigned to 'rng'
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ IDENT, ESCAPED_IDENT }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Rule Reference: list_of_port_identifiers, assigned to 'ids'
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: pd = getTree().portDecl(isOnlyDefn,dir,type,rng,ovt,isReg,isSigned,ids);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN, COMMA }
	*** End Parser Rule: output_declaration
	
	
	*** Parser Rule: module_or_generate_item
		Access: public
		Return value(s): ModuleOrGenerateItem mi
		Init action:  mi=null; Object o1=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, "defparam", "localparam", "integer", "real", 
					"realtime", "time", "reg", "event", "supply0", "supply1", 
					"tri", "triand", "trior", "tri0", "tri1", "uwire", 
					"wire", "wand", "wor", "function", "task", "genvar", 
					"for", "if", "case", "assign", "initial", "always", 
					"or", IDENT, ESCAPED_IDENT, "and", "nand", "nor", 
					"xor", "xnor"
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, "defparam", "localparam", "integer", "real", 
					"realtime", "time", "reg", "event", "supply0", "supply1", 
					"tri", "triand", "trior", "tri0", "tri1", "uwire", 
					"wire", "wand", "wor", "function", "task", "genvar", 
					"for", "if", "case", "assign", "initial", "always", 
					"or", IDENT, ESCAPED_IDENT, "and", "nand", "nor", 
					"xor", "xnor"
				 }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LPAREN }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LPAREN }
					is matched.
					Rule Reference: attribute_instance
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"defparam", "localparam", "integer", "real", "realtime", 
							"time", "reg", "event", "supply0", "supply1", "tri", 
							"triand", "trior", "tri0", "tri1", "uwire", "wire", 
							"wand", "wor", "function", "task", "genvar", "for", 
							"if", "case", "assign", "initial", "always", "or", 
							IDENT, ESCAPED_IDENT, "and", "nand", "nor", "xor", 
							"xnor"
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								"integer", "real", "realtime", "time", "reg", 
								"event", "supply0", "supply1", "tri", "triand", "trior", 
								"tri0", "tri1", "uwire", "wire", "wand", "wor", 
								"function", "task", "genvar"
							 }
						is matched.
						Rule Reference: module_or_generate_item_declaration, assigned to 'o1'
						ACTION: mi = getTree().moduleOrGenItem((ModuleOrGenerateItemDecl)o1);
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "localparam" }
						is matched.
						Rule Reference: local_parameter_declaration, assigned to 'o1'
						Match token SEMI
						ACTION: mi = getTree().moduleOrGenItem((LocalParameterDecl)o1);
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ "defparam" }
						is matched.
						Rule Reference: parameter_override, assigned to 'o1'
						ACTION: mi = getTree().moduleOrGenItem((ListOf<DefparamAssign>)o1, true);
						
						Otherwise, Alternate(4) will be taken IF:
						The lookahead set: 
							{ "assign" }
						is matched.
						Rule Reference: continuous_assign, assigned to 'o1'
						ACTION: mi = getTree().moduleOrGenItem((ContinuousAssign)o1);
						
						Otherwise, Alternate(5) will be taken IF:
						The lookahead set: 
							{ 
								"or", IDENT, ESCAPED_IDENT, "and", "nand", 
								"nor", "xor", "xnor"
							 }
						is matched.
						Rule Reference: module_instantiation, assigned to 'o1'
						ACTION: mi = getTree().moduleOrGenItem((ListOf<ModuleInstance>)o1);
						
						Otherwise, Alternate(6) will be taken IF:
						The lookahead set: 
							{ "initial" }
						is matched.
						Rule Reference: initial_construct, assigned to 'o1'
						ACTION: mi = getTree().moduleOrGenItem((InitialConstruct)o1);
						
						Otherwise, Alternate(7) will be taken IF:
						The lookahead set: 
							{ "always" }
						is matched.
						Rule Reference: always_construct, assigned to 'o1'
						ACTION: mi = getTree().moduleOrGenItem((AlwaysConstruct)o1);
						
						Otherwise, Alternate(8) will be taken IF:
						The lookahead set: 
							{ "for" }
						is matched.
						Rule Reference: loop_generate_construct, assigned to 'o1'
						ACTION: mi = getTree().moduleOrGenItem((LoopGenerateConstruct)o1);
						
						Otherwise, Alternate(9) will be taken IF:
						The lookahead set: 
							{ "if", "case" }
						is matched.
						Rule Reference: conditional_generate_construct, assigned to 'o1'
						ACTION: mi = getTree().moduleOrGenItem((ConditionalGenerateConstruct)o1);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: module_or_generate_item
	
	
	*** Parser Rule: module_or_generate_item_declaration
		Access: public
		Return value(s): ModuleOrGenerateItemDecl mogd
		Init action:  mogd=null; Object o1=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"integer", "real", "realtime", "time", "reg", 
					"event", "supply0", "supply1", "tri", "triand", "trior", 
					"tri0", "tri1", "uwire", "wire", "wand", "wor", 
					"function", "task", "genvar"
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ 
						"supply0", "supply1", "tri", "triand", "trior", 
						"tri0", "tri1", "uwire", "wire", "wand", "wor"
					 }
				is matched.
				Rule Reference: net_declaration, assigned to 'o1'
				ACTION: mogd = getTree().moduleOrGenItemDecl((NetDeclaration)o1);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ "reg" }
				is matched.
				Rule Reference: reg_declaration, assigned to 'o1'
				ACTION: mogd = getTree().moduleOrGenItemDecl((RegDecl)o1);
				
				Otherwise, Alternate(3) will be taken IF:
				The lookahead set: 
					{ "integer" }
				is matched.
				Rule Reference: integer_declaration, assigned to 'o1'
				ACTION: mogd = getTree().moduleOrGenItemDecl((IntegerDecl)o1);
				
				Otherwise, Alternate(4) will be taken IF:
				The lookahead set: 
					{ "real" }
				is matched.
				Rule Reference: real_declaration, assigned to 'o1'
				ACTION: mogd = getTree().moduleOrGenItemDecl((RealDecl)o1);
				
				Otherwise, Alternate(5) will be taken IF:
				The lookahead set: 
					{ "time" }
				is matched.
				Rule Reference: time_declaration, assigned to 'o1'
				ACTION: mogd = getTree().moduleOrGenItemDecl((TimeDecl)o1);
				
				Otherwise, Alternate(6) will be taken IF:
				The lookahead set: 
					{ "realtime" }
				is matched.
				Rule Reference: realtime_declaration, assigned to 'o1'
				ACTION: mogd = getTree().moduleOrGenItemDecl((RealtimeDecl)o1);
				
				Otherwise, Alternate(7) will be taken IF:
				The lookahead set: 
					{ "event" }
				is matched.
				Rule Reference: event_declaration, assigned to 'o1'
				ACTION: mogd = getTree().moduleOrGenItemDecl((EventDecl)o1);
				
				Otherwise, Alternate(8) will be taken IF:
				The lookahead set: 
					{ "genvar" }
				is matched.
				Rule Reference: genvar_declaration, assigned to 'o1'
				ACTION: mogd = getTree().moduleOrGenItemDecl((ListOf<GenvarIdent>)o1);
				
				Otherwise, Alternate(9) will be taken IF:
				The lookahead set: 
					{ "task" }
				is matched.
				Rule Reference: task_declaration, assigned to 'o1'
				ACTION: mogd = getTree().moduleOrGenItemDecl((TaskDeclaration)o1);
				
				Otherwise, Alternate(10) will be taken IF:
				The lookahead set: 
					{ "function" }
				is matched.
				Rule Reference: function_declaration, assigned to 'o1'
				ACTION: mogd = getTree().moduleOrGenItemDecl((FuncDecl)o1);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: module_or_generate_item_declaration
	
	
	*** Parser Rule: local_parameter_declaration
		Access: public
		Return value(s): LocalParameterDecl lpd
		Init action:  lpd=null; boolean isSigned=false; Range rng=null; 
		ListOf<ParamAssign> lopa=null; ParameterType pt=null;
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ "localparam" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "localparam" }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {"localparam" }
						k==2: {
							LBRACK, "signed", "integer", "real", "realtime", 
							"time", IDENT, ESCAPED_IDENT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {"localparam" }
							k==2: {LBRACK, "signed", IDENT, ESCAPED_IDENT }
						is matched.
						Match string literal "localparam"
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "signed" }
									is matched.
									Match string literal "signed"
									ACTION: isSigned=true;
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ LBRACK, IDENT, ESCAPED_IDENT }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK, IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LBRACK }
									is matched.
									Rule Reference: range, assigned to 'rng'
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ IDENT, ESCAPED_IDENT }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Rule Reference: list_of_param_assignments, assigned to 'lopa'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {"localparam" }
							k==2: {"integer", "real", "realtime", "time" }
						is matched.
						Match string literal "localparam"
						Rule Reference: parameter_type, assigned to 'pt'
						Rule Reference: list_of_param_assignments, assigned to 'lopa'
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: lpd = getTree().localParameterDecl(isSigned,rng,pt,lopa);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: local_parameter_declaration
	
	
	*** Parser Rule: parameter_override
		Access: public
		Return value(s): ListOf<DefparamAssign> lopa
		Init action: lopa=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "defparam" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "defparam" }
			is matched.
			Match string literal "defparam"
			Rule Reference: list_of_defparam_assignments, assigned to 'lopa'
			Match token SEMI
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: parameter_override
	
	
	*** Parser Rule: continuous_assign
		Access: public
		Return value(s): ContinuousAssign ca
		Init action:  ca=null; Object d3=null, na=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "assign" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "assign" }
			is matched.
			Match string literal "assign"
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ POUND, LCURLY, IDENT, ESCAPED_IDENT }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ POUND }
						is matched.
						Rule Reference: delay3, assigned to 'd3'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ LCURLY, IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: list_of_net_assignments, assigned to 'na'
			Match token SEMI
			ACTION: ca = getTree().continuousAssign(d3, na);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: continuous_assign
	
	
	*** Parser Rule: module_instantiation
		Access: public
		Return value(s): ListOf<ModuleInstance> lom
		Init action: 	lom=null; Ident refNm = null; ParameterValueAssignment pva=null;
			ModuleInstance mi=null;
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"or", IDENT, ESCAPED_IDENT, "and", "nand", 
					"nor", "xor", "xnor"
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"or", IDENT, ESCAPED_IDENT, "and", "nand", 
					"nor", "xor", "xnor"
				 }
			is matched.
			Rule Reference: module_identifier, assigned to 'refNm'
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {POUND, LPAREN, IDENT, ESCAPED_IDENT }
						k==2: {
							LPAREN, RPAREN, COMMA, DOT, LCURLY, 
							LBRACK, NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, 
							MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
							BOR, RNOR, BXOR, RXNOR
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {POUND }
							k==2: {NUMBER, IDENT, ESCAPED_IDENT }
						is matched, AND the syntactic predicate:
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ POUND }
									This block has a single alternative
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ POUND }
									is matched.
									Match token POUND
									Rule Reference: delay_value
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternative block.
						is matched.
						Match token POUND
						Rule Reference: delay_value
						Warning: Rule 'delay_value' returns a value
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {POUND }
							k==2: {LPAREN }
						is matched.
						Rule Reference: parameter_value_assignment, assigned to 'pva'
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ LPAREN, IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: module_instance, assigned to 'mi'
			ACTION: lom = getTree().moduleInstantiation(lom,refNm,pva,mi);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: module_instance, assigned to 'mi'
					ACTION: lom = getTree().moduleInstantiation(lom,refNm,pva,mi);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match token SEMI
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: module_instantiation
	
	
	*** Parser Rule: initial_construct
		Access: public
		Return value(s): InitialConstruct inc
		Init action:  inc=null; Statement st=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "initial" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "initial" }
			is matched.
			Match string literal "initial"
			Rule Reference: statement, assigned to 'st'
			ACTION: inc = getTree().initialConstruct(st);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: initial_construct
	
	
	*** Parser Rule: always_construct
		Access: public
		Return value(s): AlwaysConstruct awc
		Init action:  awc=null; Statement st=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "always" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "always" }
			is matched.
			Match string literal "always"
			Rule Reference: statement, assigned to 'st'
			ACTION: awc = getTree().alwaysConstruct(st);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: always_construct
	
	
	*** Parser Rule: loop_generate_construct
		Access: public
		Return value(s): LoopGenerateConstruct lgc
		Init action:  lgc=null; GenvarInit init=null; GenvarExpression test=null;
		GenvarIteration iter=null; GenerateBlock blk=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "for" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "for" }
			is matched.
			Match string literal "for"
			Match token LPAREN
			Rule Reference: genvar_initialization, assigned to 'init'
			Match token SEMI
			Rule Reference: genvar_expression, assigned to 'test'
			Match token SEMI
			Rule Reference: genvar_iteration, assigned to 'iter'
			Match token RPAREN
			Rule Reference: generate_block, assigned to 'blk'
			ACTION: lgc = getTree().loopGenerateConstruct(init,test,iter,blk);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: loop_generate_construct
	
	
	*** Parser Rule: conditional_generate_construct
		Access: public
		Return value(s): ConditionalGenerateConstruct cgc
		Init action:  cgc=null; IfGenerateConstruct igc=null; CaseGenerateConstruct cg=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "if", "case" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "if", "case" }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ "if", "case" }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "if" }
						is matched.
						Rule Reference: if_generate_construct, assigned to 'igc'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "case" }
						is matched.
						Rule Reference: case_generate_construct, assigned to 'cg'
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: cgc = getTree().conditionalGenerateConstruct(igc,cg);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: conditional_generate_construct
	
	
	*** Parser Rule: net_declaration
		Access: public
		Return value(s): NetDeclaration nd
		Init action:  nd=null; NetType type=null; boolean isSigned=false; Range rng=null;
		Delay3 del3=null; ListOf<NetIdentifiers> nets=null; 
		ListOf<NetDeclAssign> decls=null;
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"supply0", "supply1", "tri", "triand", "trior", 
					"tri0", "tri1", "uwire", "wire", "wand", "wor"
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"supply0", "supply1", "tri", "triand", "trior", 
					"tri0", "tri1", "uwire", "wire", "wand", "wor"
				 }
			is matched.
			Rule Reference: net_type, assigned to 'type'
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							POUND, LBRACK, "signed", "vectored", "scalared", 
							IDENT, ESCAPED_IDENT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "vectored" }
						is matched.
						Match string literal "vectored"
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "scalared" }
						is matched.
						Match string literal "scalared"
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ POUND, LBRACK, "signed", IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ POUND, LBRACK, "signed", IDENT, ESCAPED_IDENT }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "signed" }
						is matched.
						Match string literal "signed"
						ACTION: isSigned=true;
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ POUND, LBRACK, IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ POUND, LBRACK, IDENT, ESCAPED_IDENT }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LBRACK }
						is matched.
						Rule Reference: range, assigned to 'rng'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ POUND, IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ POUND, IDENT, ESCAPED_IDENT }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ POUND }
						is matched.
						Rule Reference: delay3, assigned to 'del3'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {IDENT, ESCAPED_IDENT }
						k==2: {SEMI, COMMA, LBRACK, ASSIGN }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {IDENT, ESCAPED_IDENT }
							k==2: {SEMI, COMMA, LBRACK }
						is matched.
						Rule Reference: list_of_net_identifiers, assigned to 'nets'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {IDENT, ESCAPED_IDENT }
							k==2: {ASSIGN }
						is matched.
						Rule Reference: list_of_net_decl_assignments, assigned to 'decls'
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Match token SEMI
			ACTION: nd=getTree().netDeclaration(type,isSigned,rng,del3,nets,decls);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: net_declaration
	
	
	*** Parser Rule: reg_declaration
		Access: public
		Return value(s): RegDecl rd
		Init action:  rd=null; boolean isSigned=false; Range rng=null; 
		ListOf<VariableType> vid=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "reg" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "reg" }
			is matched.
			Match string literal "reg"
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "signed" }
						is matched.
						Match string literal "signed"
						ACTION: isSigned=true;
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ LBRACK, IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ LBRACK, IDENT, ESCAPED_IDENT }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LBRACK }
						is matched.
						Rule Reference: range, assigned to 'rng'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: list_of_variable_identifiers, assigned to 'vid'
			Match token SEMI
			ACTION: rd=getTree().regDecl(isSigned,rng,vid);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: reg_declaration
	
	
	*** Parser Rule: integer_declaration
		Access: public
		Return value(s): IntegerDecl intd
		Init action:  intd=null; ListOf<VariableType> lovt=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "integer" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "integer" }
			is matched.
			Match string literal "integer"
			Rule Reference: list_of_variable_identifiers, assigned to 'lovt'
			Match token SEMI
			ACTION: intd = getTree().integerDecl(lovt);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: integer_declaration
	
	
	*** Parser Rule: real_declaration
		Access: public
		Return value(s): RealDecl rd
		Init action:  rd=null; ListOf<RealType> lort=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "real" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "real" }
			is matched.
			Match string literal "real"
			Rule Reference: list_of_real_identifiers, assigned to 'lort'
			Match token SEMI
			ACTION: rd=getTree().realDecl(lort);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: real_declaration
	
	
	*** Parser Rule: time_declaration
		Access: public
		Return value(s): TimeDecl td
		Init action:  td=null; ListOf<VariableType> vid=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "time" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "time" }
			is matched.
			Match string literal "time"
			Rule Reference: list_of_variable_identifiers, assigned to 'vid'
			Match token SEMI
			ACTION: td = getTree().timeDecl(vid);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: time_declaration
	
	
	*** Parser Rule: realtime_declaration
		Access: public
		Return value(s): RealtimeDecl rtd
		Init action:  rtd=null; ListOf<RealType> lort=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "realtime" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "realtime" }
			is matched.
			Match string literal "realtime"
			Rule Reference: list_of_real_identifiers, assigned to 'lort'
			Match token SEMI
			ACTION: rtd=getTree().realtimeDecl(lort);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: realtime_declaration
	
	
	*** Parser Rule: event_declaration
		Access: public
		Return value(s): EventDecl ed
		Init action:  ed=null; ListOf<EventIdentifiers> loei=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "event" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "event" }
			is matched.
			Match string literal "event"
			Rule Reference: list_of_event_identifiers, assigned to 'loei'
			Match token SEMI
			ACTION: ed = getTree().eventDecl(loei);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, "endmodule", POUND, LPAREN, LCURLY, 
				"defparam", "localparam", "parameter", "specparam", "integer", "real", 
				"realtime", "time", "inout", "input", "output", "reg", 
				"event", "supply0", "supply1", "tri", "triand", "trior", 
				"tri0", "tri1", "uwire", "wire", "wand", "wor", 
				"function", "task", "generate", "endgenerate", "genvar", "for", 
				"if", "else", "case", "endcase", "default", "begin", 
				"end", "assign", "initial", "always", "deassign", "force", 
				"release", "fork", "join", "repeat", "disable", AT, 
				TRIGGER, "or", "wait", "casex", "casez", "forever", 
				"while", NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, 
				"and", "nand", "nor", "xor", "xnor", MINUS, 
				PLUS, LNOT, BNOT, BAND, RNAND, BOR, 
				RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: event_declaration
	
	
	*** Parser Rule: genvar_declaration
		Access: public
		Return value(s): ListOf<GenvarIdent> loi
		Init action:  loi=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "genvar" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "genvar" }
			is matched.
			Match string literal "genvar"
			Rule Reference: list_of_genvar_identifiers, assigned to 'loi'
			Match token SEMI
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: genvar_declaration
	
	
	*** Parser Rule: task_declaration
		Access: public
		Return value(s): TaskDeclaration td
		Init action:  td=null; TaskIdent id=null; boolean isAuto=false;
		TaskItemDecl tid=null; BlockItemDecl bid=null;
		ListOf<TfPortDeclaration> lop=null; Statement st=null;
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ "task" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "task" }
			is matched.
			Match string literal "task"
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ "automatic", IDENT, ESCAPED_IDENT }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "automatic" }
						is matched.
						Match string literal "automatic"
						ACTION: isAuto=true;
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: task_identifier, assigned to 'id'
			ACTION: td = getTree().taskDecl(isAuto, id);
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ SEMI, LPAREN }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ SEMI }
						is matched.
						Match token SEMI
						Start ZERO-OR-MORE (...)+ block:
							Warning: This zero-or-more block is non-deterministic
							Start of an alternative block.
								The lookahead set for this block is:
									k==1: {
										LPAREN, "localparam", "parameter", "integer", "real", 
										"realtime", "time", "inout", "input", "output", "reg", 
										"event"
									 }
									k==2: {
										LBRACK, "signed", "integer", "real", "realtime", 
										"time", "reg", STAR, IDENT, ESCAPED_IDENT
									 }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									k==1: {
										LPAREN, "localparam", "parameter", "integer", "real", 
										"realtime", "time", "inout", "input", "output", "reg", 
										"event"
									 }
									k==2: {
										LBRACK, "signed", "integer", "real", "realtime", 
										"time", "reg", STAR, IDENT, ESCAPED_IDENT
									 }
								is matched.
								Rule Reference: task_item_declaration, assigned to 'tid'
								ACTION: getTree().taskDecl(td, tid);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ LPAREN }
						is matched.
						Match token LPAREN
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LPAREN, RPAREN, "inout", "input", "output" }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LPAREN, "inout", "input", "output" }
									is matched.
									Rule Reference: task_port_list, assigned to 'lop'
									ACTION: getTree().taskDecl(td,lop);
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ RPAREN }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Match token RPAREN
						Match token SEMI
						Start ZERO-OR-MORE (...)+ block:
							Warning: This zero-or-more block is non-deterministic
							Start of an alternative block.
								The lookahead set for this block is:
									k==1: {
										LPAREN, "localparam", "parameter", "integer", "real", 
										"realtime", "time", "reg", "event"
									 }
									k==2: {
										LBRACK, "signed", "integer", "real", "realtime", 
										"time", STAR, IDENT, ESCAPED_IDENT
									 }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									k==1: {
										LPAREN, "localparam", "parameter", "integer", "real", 
										"realtime", "time", "reg", "event"
									 }
									k==2: {
										LBRACK, "signed", "integer", "real", "realtime", 
										"time", STAR, IDENT, ESCAPED_IDENT
									 }
								is matched.
								Rule Reference: block_item_declaration, assigned to 'bid'
								ACTION: getTree().taskDecl(td, bid);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: statement_or_null, assigned to 'st'
			ACTION: getTree().taskDecl(td, st);
			Match string literal "endtask"
			ACTION: getTree().popScope();
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: task_declaration
	
	
	*** Parser Rule: function_declaration
		Access: public
		Return value(s): FuncDecl fd
		Init action: fd=null; boolean isAuto=false; FuncType ft=null; FuncIdent id=null;
			FuncItemDecl fid=null; ListOf<FuncItemDecl> lofid=null;
			ListOf<TfPortDeclaration> lop=null; 
			BlockItemDecl bid=null; ListOf<BlockItemDecl> lobid=null;
			FuncStatement stmt=null;
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ "function" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "function" }
			is matched.
			Match string literal "function"
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							LBRACK, "signed", "integer", "real", "realtime", 
							"time", "automatic", IDENT, ESCAPED_IDENT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "automatic" }
						is matched.
						Match string literal "automatic"
						ACTION: isAuto=true;
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								LBRACK, "signed", "integer", "real", "realtime", 
								"time", IDENT, ESCAPED_IDENT
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {
							LBRACK, "signed", "integer", "real", "realtime", 
							"time", IDENT, ESCAPED_IDENT
						 }
						k==2: {
							SEMI, LPAREN, LCURLY, LBRACK, NUMBER, 
							STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
							LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
							BXOR, RXNOR
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {
								LBRACK, "signed", "integer", "real", "realtime", 
								"time", IDENT, ESCAPED_IDENT
							 }
							k==2: {
								SEMI, LPAREN, LCURLY, LBRACK, NUMBER, 
								STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
								LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
								BXOR, RXNOR
							 }
						is matched.
						Rule Reference: function_range_or_type, assigned to 'ft'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {IDENT, ESCAPED_IDENT }
							k==2: {SEMI, LPAREN }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: function_identifier, assigned to 'id'
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ SEMI, LPAREN }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ SEMI }
						is matched.
						Match token SEMI
						Start ONE-OR-MORE (...)+ block:
							Warning: This one-or-more block is non-deterministic
							Start of an alternative block.
								The lookahead set for this block is:
									k==1: {
										LPAREN, "localparam", "parameter", "integer", "real", 
										"realtime", "time", "input", "reg", "event"
									 }
									k==2: {
										LBRACK, "signed", "integer", "real", "realtime", 
										"time", "reg", STAR, IDENT, ESCAPED_IDENT
									 }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									k==1: {
										LPAREN, "localparam", "parameter", "integer", "real", 
										"realtime", "time", "input", "reg", "event"
									 }
									k==2: {
										LBRACK, "signed", "integer", "real", "realtime", 
										"time", "reg", STAR, IDENT, ESCAPED_IDENT
									 }
								is matched.
								Rule Reference: function_item_declaration, assigned to 'fid'
								ACTION: lofid=getTree().addToList(lofid,fid);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ONE-OR-MORE block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ LPAREN }
						is matched.
						Match token LPAREN
						Rule Reference: function_port_list, assigned to 'lop'
						Match token RPAREN
						Match token SEMI
						Start ZERO-OR-MORE (...)+ block:
							Warning: This zero-or-more block is non-deterministic
							Start of an alternative block.
								The lookahead set for this block is:
									k==1: {
										LPAREN, "localparam", "parameter", "integer", "real", 
										"realtime", "time", "reg", "event"
									 }
									k==2: {
										LBRACK, "signed", "integer", "real", "realtime", 
										"time", STAR, IDENT, ESCAPED_IDENT
									 }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									k==1: {
										LPAREN, "localparam", "parameter", "integer", "real", 
										"realtime", "time", "reg", "event"
									 }
									k==2: {
										LBRACK, "signed", "integer", "real", "realtime", 
										"time", STAR, IDENT, ESCAPED_IDENT
									 }
								is matched.
								Rule Reference: block_item_declaration, assigned to 'bid'
								ACTION: lobid=getTree().addToList(lobid,bid);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: function_statement, assigned to 'stmt'
			Match string literal "endfunction"
			ACTION: 	fd = getTree().funcDecl(isAuto,ft,id,lofid,lop,lobid,stmt);
						 	getTree().popScope();
						
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: function_declaration
	
	
	*** Parser Rule: generate_region
		Access: public
		Return value(s): ListOf<ModuleOrGenerateItem> loi
		Init action:  loi=null; ModuleOrGenerateItem mi=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "generate" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "generate" }
			is matched.
			Match string literal "generate"
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							LPAREN, "defparam", "localparam", "integer", "real", 
							"realtime", "time", "reg", "event", "supply0", "supply1", 
							"tri", "triand", "trior", "tri0", "tri1", "uwire", 
							"wire", "wand", "wor", "function", "task", "genvar", 
							"for", "if", "case", "assign", "initial", "always", 
							"or", IDENT, ESCAPED_IDENT, "and", "nand", "nor", 
							"xor", "xnor"
						 }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ 
							LPAREN, "defparam", "localparam", "integer", "real", 
							"realtime", "time", "reg", "event", "supply0", "supply1", 
							"tri", "triand", "trior", "tri0", "tri1", "uwire", 
							"wire", "wand", "wor", "function", "task", "genvar", 
							"for", "if", "case", "assign", "initial", "always", 
							"or", IDENT, ESCAPED_IDENT, "and", "nand", "nor", 
							"xor", "xnor"
						 }
					is matched.
					Rule Reference: module_or_generate_item, assigned to 'mi'
					ACTION: loi = getTree().addToList(loi, mi);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match string literal "endgenerate"
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, "defparam", "localparam", "parameter", 
				"specparam", "integer", "real", "realtime", "time", "inout", 
				"input", "output", "reg", "event", "supply0", "supply1", 
				"tri", "triand", "trior", "tri0", "tri1", "uwire", 
				"wire", "wand", "wor", "function", "task", "generate", 
				"genvar", "for", "if", "case", "assign", "initial", 
				"always", "or", IDENT, ESCAPED_IDENT, "and", "nand", 
				"nor", "xor", "xnor"
			 }
	*** End Parser Rule: generate_region
	
	
	*** Parser Rule: specparam_declaration
		Access: public
		Return value(s): SpecparamDecl spd
		Init action:  spd=null; Range rng=null; ListOf<SpecparamAssign> spa=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "specparam" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "specparam" }
			is matched.
			Match string literal "specparam"
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ LBRACK, IDENT, ESCAPED_IDENT }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LBRACK }
						is matched.
						Rule Reference: range, assigned to 'rng'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ IDENT, ESCAPED_IDENT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: list_of_specparam_assignments, assigned to 'spa'
			Match token SEMI
			ACTION: spd = getTree().specparamDecl(rng,spa);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, "defparam", "localparam", "parameter", 
				"specparam", "integer", "real", "realtime", "time", "inout", 
				"input", "output", "reg", "event", "supply0", "supply1", 
				"tri", "triand", "trior", "tri0", "tri1", "uwire", 
				"wire", "wand", "wor", "function", "task", "generate", 
				"genvar", "for", "if", "case", "assign", "initial", 
				"always", "or", IDENT, ESCAPED_IDENT, "and", "nand", 
				"nor", "xor", "xnor"
			 }
	*** End Parser Rule: specparam_declaration
	
	
	*** Parser Rule: list_of_defparam_assignments
		Access: public
		Return value(s): ListOf<DefparamAssign> loda
		Init action:  loda=null; DefparamAssign da=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: defparam_assignment, assigned to 'da'
			ACTION: loda=getTree().addToList(loda,da);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: defparam_assignment, assigned to 'da'
					ACTION: loda=getTree().addToList(loda,da);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: list_of_defparam_assignments
	
	
	*** Parser Rule: range
		Access: public
		Return value(s): Range rng
		Init action:  rng=null; ConstExpression msb=null, lsb=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LBRACK }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LBRACK }
			is matched.
			Match token LBRACK
			Rule Reference: msb_constant_expression, assigned to 'msb'
			Match token COLON
			Rule Reference: lsb_constant_expression, assigned to 'lsb'
			Match token RBRACK
			ACTION: rng = getTree().range(msb,lsb);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {POUND, LPAREN, IDENT, ESCAPED_IDENT }
	*** End Parser Rule: range
	
	
	*** Parser Rule: list_of_param_assignments
		Access: public
		Return value(s): ListOf<ParamAssign> lopa
		Init action:  lopa=null; ParamAssign pa=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: param_assignment, assigned to 'pa'
			ACTION: lopa=getTree().addToList(lopa,pa);
			Start ZERO-OR-MORE (...)+ block:
				Warning: This zero-or-more block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {COMMA }
						k==2: {IDENT, ESCAPED_IDENT }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						k==1: {COMMA }
						k==2: {IDENT, ESCAPED_IDENT }
					is matched.
					Match token COMMA
					Rule Reference: param_assignment, assigned to 'pa'
					ACTION: lopa=getTree().addToList(lopa,pa);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN, COMMA }
	*** End Parser Rule: list_of_param_assignments
	
	
	*** Parser Rule: parameter_type
		Access: public
		Return value(s): ParameterType pt
		Init action:  pt = getTree().parameterType(LA(1));
		Start of an alternative block.
			The lookahead set for this block is:
				{ "integer", "real", "realtime", "time" }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ "integer" }
				is matched.
				Match string literal "integer"
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ "real" }
				is matched.
				Match string literal "real"
				
				Otherwise, Alternate(3) will be taken IF:
				The lookahead set: 
					{ "realtime" }
				is matched.
				Match string literal "realtime"
				
				Otherwise, Alternate(4) will be taken IF:
				The lookahead set: 
					{ "time" }
				is matched.
				Match string literal "time"
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {IDENT, ESCAPED_IDENT }
	*** End Parser Rule: parameter_type
	
	
	*** Parser Rule: list_of_specparam_assignments
		Access: public
		Return value(s): ListOf<SpecparamAssign> spa
		Init action:  spa=null; SpecparamAssign sa=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: specparam_assignment, assigned to 'sa'
			ACTION: spa=getTree().addToList(spa,sa);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: specparam_assignment, assigned to 'sa'
					ACTION: spa=getTree().addToList(spa,sa);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: list_of_specparam_assignments
	
	
	*** Parser Rule: net_type
		Access: public
		Return value(s): NetType nt
		Init action:  nt=null; int type=LA(1); nt = getTree().netType(type);
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"supply0", "supply1", "tri", "triand", "trior", 
					"tri0", "tri1", "uwire", "wire", "wand", "wor"
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ "supply0" }
				is matched.
				Match string literal "supply0"
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ "supply1" }
				is matched.
				Match string literal "supply1"
				
				Otherwise, Alternate(3) will be taken IF:
				The lookahead set: 
					{ "tri" }
				is matched.
				Match string literal "tri"
				
				Otherwise, Alternate(4) will be taken IF:
				The lookahead set: 
					{ "triand" }
				is matched.
				Match string literal "triand"
				
				Otherwise, Alternate(5) will be taken IF:
				The lookahead set: 
					{ "trior" }
				is matched.
				Match string literal "trior"
				
				Otherwise, Alternate(6) will be taken IF:
				The lookahead set: 
					{ "tri0" }
				is matched.
				Match string literal "tri0"
				
				Otherwise, Alternate(7) will be taken IF:
				The lookahead set: 
					{ "tri1" }
				is matched.
				Match string literal "tri1"
				
				Otherwise, Alternate(8) will be taken IF:
				The lookahead set: 
					{ "uwire" }
				is matched.
				Match string literal "uwire"
				
				Otherwise, Alternate(9) will be taken IF:
				The lookahead set: 
					{ "wire" }
				is matched.
				Match string literal "wire"
				
				Otherwise, Alternate(10) will be taken IF:
				The lookahead set: 
					{ "wand" }
				is matched.
				Match string literal "wand"
				
				Otherwise, Alternate(11) will be taken IF:
				The lookahead set: 
					{ "wor" }
				is matched.
				Match string literal "wor"
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				POUND, LBRACK, "signed", "vectored", "scalared", 
				IDENT, ESCAPED_IDENT
			 }
	*** End Parser Rule: net_type
	
	
	*** Parser Rule: list_of_port_identifiers
		Access: public
		Return value(s): ListOf<PortIdent> lop
		Init action:  lop=null; PortIdent pi=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: port_identifier, assigned to 'pi'
			ACTION: lop = getTree().addToList(lop,pi);
			Start ZERO-OR-MORE (...)+ block:
				Warning: This zero-or-more block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {COMMA }
						k==2: {IDENT, ESCAPED_IDENT }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						k==1: {COMMA }
						k==2: {IDENT, ESCAPED_IDENT }
					is matched.
					Match token COMMA
					Rule Reference: port_identifier, assigned to 'pi'
					ACTION: lop = getTree().addToList(lop,pi);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN, COMMA }
	*** End Parser Rule: list_of_port_identifiers
	
	
	*** Parser Rule: output_variable_type
		Access: public
		Return value(s): OutputVarType ovt
		Init action:  ovt=null; int type=LA(1); ovt = getTree().outputVarType(type);
		Start of an alternative block.
			The lookahead set for this block is:
				{ "integer", "time" }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ "integer" }
				is matched.
				Match string literal "integer"
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ "time" }
				is matched.
				Match string literal "time"
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {IDENT, ESCAPED_IDENT }
	*** End Parser Rule: output_variable_type
	
	
	*** Parser Rule: list_of_variable_port_identifiers
		Access: public
		Return value(s): ListOf<PortIdents> lopi
		Init action:  lopi=null; PortIdents pis=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: port_identifiers, assigned to 'pis'
			ACTION: lopi=getTree().addToList(lopi,pis);
			Start ZERO-OR-MORE (...)+ block:
				Warning: This zero-or-more block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {COMMA }
						k==2: {IDENT, ESCAPED_IDENT }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						k==1: {COMMA }
						k==2: {IDENT, ESCAPED_IDENT }
					is matched.
					Match token COMMA
					Rule Reference: port_identifiers, assigned to 'pis'
					ACTION: lopi=getTree().addToList(lopi,pis);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN, COMMA }
	*** End Parser Rule: list_of_variable_port_identifiers
	
	
	*** Parser Rule: list_of_event_identifiers
		Access: public
		Return value(s): ListOf<EventIdentifiers> loei
		Init action:  loei=null; EventIdentifiers ei=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: event_identifiers, assigned to 'ei'
			ACTION: loei=getTree().addToList(loei,ei);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: event_identifiers, assigned to 'ei'
					ACTION: loei=getTree().addToList(loei,ei);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: list_of_event_identifiers
	
	
	*** Parser Rule: list_of_variable_identifiers
		Access: public
		Return value(s): ListOf<VariableType> lovt
		Init action:  lovt=null; VariableType vt=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: variable_type, assigned to 'vt'
			ACTION: lovt = getTree().addToList(lovt,vt);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: variable_type, assigned to 'vt'
					ACTION: lovt = getTree().addToList(lovt,vt);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: list_of_variable_identifiers
	
	
	*** Parser Rule: delay3
		Access: public
		Return value(s): Delay3 d3
		Init action:  d3=null; ListOf<DelayValue> lo=null; DelayValue dv=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ POUND }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ POUND }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {POUND }
						k==2: {LPAREN, NUMBER, IDENT, ESCAPED_IDENT }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {POUND }
							k==2: {NUMBER, IDENT, ESCAPED_IDENT }
						is matched.
						Match token POUND
						Rule Reference: delay_value, assigned to 'dv'
						ACTION: lo = getTree().addToList(lo, dv);
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {POUND }
							k==2: {LPAREN }
						is matched.
						Match token POUND
						Match token LPAREN
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ NUMBER, IDENT, ESCAPED_IDENT }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ NUMBER, IDENT, ESCAPED_IDENT }
								is matched.
								Rule Reference: delay_value, assigned to 'dv'
								ACTION: lo = getTree().addToList(lo, dv);
								Start ZERO-OR-MORE (...)+ block:
									Start of an alternative block.
										The lookahead set for this block is:
											{ COMMA }
										This block has a single alternative
										
										Alternate(1) will be taken IF:
										The lookahead set: 
											{ COMMA }
										is matched.
										Match token COMMA
										Rule Reference: delay_value, assigned to 'dv'
										ACTION: getTree().addToList(lo, dv);
										
										OTHERWISE, a NoViableAlt exception will be thrown
										
									End of alternative block.
								End ZERO-OR-MORE block.
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						Match token RPAREN
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: d3 = getTree().delay3(lo);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {EOF, LCURLY, IDENT, ESCAPED_IDENT }
	*** End Parser Rule: delay3
	
	
	*** Parser Rule: list_of_net_identifiers
		Access: public
		Return value(s): ListOf<NetIdentifiers> loni
		Init action:  loni=null; NetIdentifiers ni=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: net_identifiers, assigned to 'ni'
			ACTION: loni=getTree().addToList(loni,ni);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: net_identifiers, assigned to 'ni'
					ACTION: loni=getTree().addToList(loni,ni);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: list_of_net_identifiers
	
	
	*** Parser Rule: list_of_net_decl_assignments
		Access: public
		Return value(s): ListOf<NetDeclAssign>	loda
		Init action:  loda=null; NetDeclAssign nda=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: net_decl_assignment, assigned to 'nda'
			ACTION: loda=getTree().addToList(loda,nda);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: net_decl_assignment, assigned to 'nda'
					ACTION: loda=getTree().addToList(loda,nda);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: list_of_net_decl_assignments
	
	
	*** Parser Rule: list_of_real_identifiers
		Access: public
		Return value(s): ListOf<RealType> lort
		Init action:  lort=null; RealType rt=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: real_type, assigned to 'rt'
			ACTION: lort=getTree().addToList(lort,rt);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: real_type, assigned to 'rt'
					ACTION: lort=getTree().addToList(lort,rt);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: list_of_real_identifiers
	
	
	*** Parser Rule: real_type
		Access: public
		Return value(s): RealType rt
		Init action:  rt=null; RealIdent id=null; 
		Dimension dim=null; ListOf<Dimension> lod=null; 
		ConstExpression expr=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {IDENT, ESCAPED_IDENT }
						k==2: {SEMI, COMMA, LBRACK, ASSIGN }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {IDENT, ESCAPED_IDENT }
							k==2: {SEMI, COMMA, LBRACK }
						is matched.
						Rule Reference: real_identifier, assigned to 'id'
						Start ZERO-OR-MORE (...)+ block:
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ LBRACK }
								is matched.
								Rule Reference: dimension, assigned to 'dim'
								ACTION: lod = getTree().addToList(lod, dim);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {IDENT, ESCAPED_IDENT }
							k==2: {ASSIGN }
						is matched.
						Rule Reference: real_identifier, assigned to 'id'
						Match token ASSIGN
						Rule Reference: constant_expression, assigned to 'expr'
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: rt = getTree().realType(id,lod,expr);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA }
	*** End Parser Rule: real_type
	
	
	*** Parser Rule: real_identifier
		Access: public
		Return value(s): RealIdent rid
		Init action:  rid=null; Ident id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'id'
			ACTION: rid = getTree().realIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA, LBRACK, ASSIGN }
	*** End Parser Rule: real_identifier
	
	
	*** Parser Rule: dimension
		Access: public
		Return value(s): Dimension dim
		Init action:  dim=null; ConstExpression msb=null, lsb=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LBRACK }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LBRACK }
			is matched.
			Match token LBRACK
			Rule Reference: dimension_constant_expression, assigned to 'msb'
			Match token COLON
			Rule Reference: dimension_constant_expression, assigned to 'lsb'
			Match token RBRACK
			ACTION: dim = getTree().dimension(msb,lsb);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA, LBRACK }
	*** End Parser Rule: dimension
	
	
	*** Parser Rule: constant_expression
		Access: public
		Return value(s): ConstExpression ce
		Init action:  ce=null; Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Rule Reference: expression, assigned to 'exp'
			ACTION: ce = getTree().constantExpression(exp);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, RPAREN, COMMA, LCURLY, 
				RBRACK, COLON, STAR, PLUS_COLON, MINUS_COLON
			 }
	*** End Parser Rule: constant_expression
	
	
	*** Parser Rule: variable_type
		Access: public
		Return value(s): VariableType vt
		Init action:  vt=null; VariableIdent id=null; 
		Dimension dim=null; ListOf<Dimension> lod=null; 
		ConstExpression expr=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {IDENT, ESCAPED_IDENT }
						k==2: {SEMI, COMMA, LBRACK, ASSIGN }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {IDENT, ESCAPED_IDENT }
							k==2: {SEMI, COMMA, LBRACK }
						is matched.
						Rule Reference: variable_identifier, assigned to 'id'
						Start ZERO-OR-MORE (...)+ block:
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ LBRACK }
								is matched.
								Rule Reference: dimension, assigned to 'dim'
								ACTION: lod = getTree().addToList(lod, dim);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {IDENT, ESCAPED_IDENT }
							k==2: {ASSIGN }
						is matched.
						Rule Reference: variable_identifier, assigned to 'id'
						Match token ASSIGN
						Rule Reference: constant_expression, assigned to 'expr'
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: vt = getTree().varType(id,lod,expr);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA }
	*** End Parser Rule: variable_type
	
	
	*** Parser Rule: variable_identifier
		Access: public
		Return value(s): VariableIdent rid
		Init action:  rid=null; Ident id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'id'
			ACTION: rid = getTree().variableIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA, LBRACK, ASSIGN }
	*** End Parser Rule: variable_identifier
	
	
	*** Parser Rule: delay_value
		Access: public
		Return value(s): DelayValue dv
		Init action:  dv=null; Vnumber n=null; Ident id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ NUMBER, IDENT, ESCAPED_IDENT }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ NUMBER }
				is matched.
				Rule Reference: number, assigned to 'n'
				ACTION: dv = getTree().delayValue(n);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ IDENT, ESCAPED_IDENT }
				is matched.
				Rule Reference: identifier, assigned to 'id'
				ACTION: dv = getTree().delayValue(id);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, POUND, LPAREN, RPAREN, 
				COMMA, LCURLY, "for", "if", "case", "begin", 
				"assign", "deassign", "force", "release", "fork", "repeat", 
				"disable", AT, TRIGGER, "wait", "casex", "casez", 
				"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, BAND, 
				RNAND, BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: delay_value
	
	
	*** Parser Rule: delay2
		Access: public
		Return value(s): Delay2 d2
		Init action:  d2=null; Delay3 d3=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ POUND }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ POUND }
			is matched.
			Rule Reference: delay3, assigned to 'd3'
			ACTION: d2 = getTree().delay2(d3);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {EOF }
	*** End Parser Rule: delay2
	
	
	*** Parser Rule: number
		Access: public
		Return value(s): Vnumber n
		Init action:  n = null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ NUMBER }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ NUMBER }
			is matched.
			Match token NUMBER, label=tk
			ACTION: n = getTree().number(tk);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, POUND, LPAREN, RPAREN, 
				COMMA, LCURLY, RCURLY, RBRACK, COLON, "for", 
				QMARK, "if", "case", "begin", "assign", LE, 
				"deassign", "force", "release", "fork", "repeat", "disable", 
				AT, STAR, TRIGGER, "or", "wait", "casex", 
				"casez", "forever", "while", PLUS_COLON, MINUS_COLON, NUMBER, 
				STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
				LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
				BXOR, RXNOR, DIV, MOD, EQUAL, NOT_EQ, 
				NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, GT, 
				GE, SR, SL, SR3, SL3, STAR2
			 }
	*** End Parser Rule: number
	
	
	*** Parser Rule: identifier
		Access: public
		Return value(s): Ident id
		Init action: 	id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ IDENT }
				is matched.
				Match token IDENT, label=tk
				ACTION: id = new Ident(tk);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ ESCAPED_IDENT }
				is matched.
				Match token ESCAPED_IDENT, label=tk2
				ACTION: id = new Ident(tk2);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, POUND, LPAREN, RPAREN, 
				COMMA, DOT, LCURLY, RCURLY, LBRACK, RBRACK, 
				"defparam", "localparam", "parameter", "integer", "real", "realtime", 
				"time", "reg", "event", "supply0", "supply1", "tri", 
				"triand", "trior", "tri0", "tri1", "uwire", "wire", 
				"wand", "wor", ASSIGN, COLON, "function", "task", 
				"genvar", "for", QMARK, "if", "case", "begin", 
				"end", "assign", "initial", "always", LE, "deassign", 
				"force", "release", "fork", "join", "repeat", "disable", 
				AT, STAR, TRIGGER, "or", "wait", "casex", 
				"casez", "forever", "while", PLUS_COLON, MINUS_COLON, NUMBER, 
				STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, "and", "nand", 
				"nor", "xor", "xnor", MINUS, PLUS, LNOT, 
				BNOT, BAND, RNAND, BOR, RNOR, BXOR, 
				RXNOR, DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, 
				EQ_CASE, LAND, LOR, LT_, GT, GE, 
				SR, SL, SR3, SL3, STAR2
			 }
	*** End Parser Rule: identifier
	
	
	*** Parser Rule: defparam_assignment
		Access: public
		Return value(s): DefparamAssign dpa
		Init action:  dpa=null; HierParameterIdent hpi=null; ConstMinTypMaxExpression mtm=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: hierarchical_parameter_identifier, assigned to 'hpi'
			Match token ASSIGN
			Rule Reference: constant_mintypmax_expression, assigned to 'mtm'
			ACTION: dpa = getTree().defparamAssign(hpi,mtm);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA }
	*** End Parser Rule: defparam_assignment
	
	
	*** Parser Rule: event_identifiers
		Access: public
		Return value(s): EventIdentifiers eis
		Init action:  eis=null; EventIdent ei=null; Dimension dim=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: event_identifier, assigned to 'ei'
			ACTION: eis=getTree().eventIdentifiers(null,ei,null);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LBRACK }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LBRACK }
					is matched.
					Rule Reference: dimension, assigned to 'dim'
					ACTION: eis=getTree().eventIdentifiers(eis,null,dim);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA }
	*** End Parser Rule: event_identifiers
	
	
	*** Parser Rule: event_identifier
		Access: public
		Return value(s): EventIdent rid
		Init action:  rid=null; Ident id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'id'
			ACTION: rid = getTree().eventIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA, LBRACK }
	*** End Parser Rule: event_identifier
	
	
	*** Parser Rule: net_decl_assignment
		Access: public
		Return value(s): NetDeclAssign nda
		Init action:  nda=null; NetIdent id=null; Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: net_identifier, assigned to 'id'
			Match token ASSIGN
			Rule Reference: expression, assigned to 'exp'
			ACTION: nda = getTree().netDeclAssign(id,exp);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA }
	*** End Parser Rule: net_decl_assignment
	
	
	*** Parser Rule: net_identifiers
		Access: public
		Return value(s): NetIdentifiers nis
		Init action:  nis=null; NetIdent ni=null; Dimension dim=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: net_identifier, assigned to 'ni'
			ACTION: nis=getTree().netIdentifiers(null,ni,null);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LBRACK }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LBRACK }
					is matched.
					Rule Reference: dimension, assigned to 'dim'
					ACTION: nis=getTree().netIdentifiers(nis,null,dim);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA }
	*** End Parser Rule: net_identifiers
	
	
	*** Parser Rule: net_identifier
		Access: public
		Return value(s): NetIdent rid
		Init action:  rid=null; Ident id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'id'
			ACTION: rid = getTree().netIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA, LBRACK, ASSIGN }
	*** End Parser Rule: net_identifier
	
	
	*** Parser Rule: param_assignment
		Access: public
		Return value(s): ParamAssign pa
		Init action:  pa=null; ParameterIdent id=null; ConstMinTypMaxExpression mtm=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: parameter_identifier, assigned to 'id'
			Match token ASSIGN
			Rule Reference: constant_mintypmax_expression, assigned to 'mtm'
			ACTION: pa = getTree().paramAssign(id,mtm);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN, COMMA }
	*** End Parser Rule: param_assignment
	
	
	*** Parser Rule: specparam_assignment
		Access: public
		Return value(s): SpecparamAssign spa
		Init action:  spa=null; SpecparamIdent id=null; ConstMinTypMaxExpression mtm=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: specparam_identifier, assigned to 'id'
			Match token ASSIGN
			Rule Reference: constant_mintypmax_expression, assigned to 'mtm'
			ACTION: spa = getTree().specparamAssign(id,mtm);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA }
	*** End Parser Rule: specparam_assignment
	
	
	*** Parser Rule: port_identifiers
		Access: public
		Return value(s): PortIdents pis
		Init action:  pis=null; PortIdent id=null; ConstExpression expr=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: port_identifier, assigned to 'id'
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ SEMI, RPAREN, COMMA, ASSIGN }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ ASSIGN }
						is matched.
						Match token ASSIGN
						Rule Reference: constant_expression, assigned to 'expr'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ SEMI, RPAREN, COMMA }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: pis = getTree().portIdents(id, expr);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN, COMMA }
	*** End Parser Rule: port_identifiers
	
	
	*** Parser Rule: hierarchical_parameter_identifier
		Access: public
		Return value(s): HierParameterIdent rid
		Init action:  rid=null; HierIdent id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: hierarchical_identifier, assigned to 'id'
			ACTION: rid = getTree().hierarchicalParameterIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {ASSIGN }
	*** End Parser Rule: hierarchical_parameter_identifier
	
	
	*** Parser Rule: constant_mintypmax_expression
		Access: public
		Return value(s): ConstMinTypMaxExpression cmtm
		Init action:  cmtm=null; ConstExpression c0=null,c1=null,c2=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Rule Reference: constant_expression, assigned to 'c0'
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ SEMI, RPAREN, COMMA, COLON }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ COLON }
						is matched.
						Match token COLON
						Rule Reference: constant_expression, assigned to 'c1'
						Match token COLON
						Rule Reference: constant_expression, assigned to 'c2'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ SEMI, RPAREN, COMMA }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: cmtm = getTree().constantMinTypeMaxExpression(c0,c1,c2);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN, COMMA }
	*** End Parser Rule: constant_mintypmax_expression
	
	
	*** Parser Rule: expression
		Access: public
		Return value(s): Expression expr
		Init action:  expr=null; Object e1=null, e2=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Rule Reference: expression_1, assigned to 'e1'
			Rule Reference: expression_2, assigned to 'e2'
			ACTION: expr = getTree().expression(e1, e2);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, RPAREN, COMMA, LCURLY, 
				RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
				"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
				BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
				NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
				GT, GE, SR, SL, SR3, SL3, 
				STAR2
			 }
	*** End Parser Rule: expression
	
	
	*** Parser Rule: parameter_identifier
		Access: public
		Return value(s): ParameterIdent rid
		Init action:  rid=null; Ident id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'id'
			ACTION: rid = getTree().parameterIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {LPAREN, ASSIGN }
	*** End Parser Rule: parameter_identifier
	
	
	*** Parser Rule: specparam_identifier
		Access: public
		Return value(s): SpecparamIdent rid
		Init action:  rid=null; Ident id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'id'
			ACTION: rid = getTree().specparamIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {ASSIGN }
	*** End Parser Rule: specparam_identifier
	
	
	*** Parser Rule: dimension_constant_expression
		Access: public
		Return value(s): ConstExpression ce
		Init action:  ce=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Rule Reference: constant_expression, assigned to 'ce'
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RBRACK, COLON }
	*** End Parser Rule: dimension_constant_expression
	
	
	*** Parser Rule: msb_constant_expression
		Access: public
		Return value(s): ConstExpression cexp
		Init action:  cexp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Rule Reference: constant_expression, assigned to 'cexp'
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {COLON }
	*** End Parser Rule: msb_constant_expression
	
	
	*** Parser Rule: lsb_constant_expression
		Access: public
		Return value(s): ConstExpression cexp
		Init action:  cexp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Rule Reference: constant_expression, assigned to 'cexp'
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RBRACK }
	*** End Parser Rule: lsb_constant_expression
	
	
	*** Parser Rule: function_range_or_type
		Access: public
		Return value(s): FuncType ft
		Init action:  ft=null; int tok=LA(1); Range rng=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LBRACK, "signed", "integer", "real", "realtime", 
					"time", IDENT, ESCAPED_IDENT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LBRACK, "signed", "integer", "real", "realtime", 
					"time", IDENT, ESCAPED_IDENT
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							LBRACK, "signed", "integer", "real", "realtime", 
							"time", IDENT, ESCAPED_IDENT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
						is matched.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "signed" }
									is matched.
									Match string literal "signed"
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ LBRACK, IDENT, ESCAPED_IDENT }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						ACTION: tok=-1;
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK, IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LBRACK }
									is matched.
									Rule Reference: range, assigned to 'rng'
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ IDENT, ESCAPED_IDENT }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "integer" }
						is matched.
						Match string literal "integer"
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ "real" }
						is matched.
						Match string literal "real"
						
						Otherwise, Alternate(4) will be taken IF:
						The lookahead set: 
							{ "realtime" }
						is matched.
						Match string literal "realtime"
						
						Otherwise, Alternate(5) will be taken IF:
						The lookahead set: 
							{ "time" }
						is matched.
						Match string literal "time"
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: ft = getTree().funcType(tok, rng);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {IDENT, ESCAPED_IDENT }
	*** End Parser Rule: function_range_or_type
	
	
	*** Parser Rule: function_identifier
		Access: public
		Return value(s): FuncIdent rid
		Init action:  rid=null; Ident id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'id'
			ACTION: 	rid = getTree().funcIdentifier(id);
						getTree().addSymbol(rid);
					
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, LPAREN }
	*** End Parser Rule: function_identifier
	
	
	*** Parser Rule: function_item_declaration
		Access: public
		Return value(s): FuncItemDecl fid
		Init action:  fid=null; TfPortDeclaration tpd=null; BlockItemDecl bid=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, "localparam", "parameter", "integer", "real", 
					"realtime", "time", "input", "reg", "event"
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, "localparam", "parameter", "integer", "real", 
					"realtime", "time", "input", "reg", "event"
				 }
			is matched.
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {
							LPAREN, "localparam", "parameter", "integer", "real", 
							"realtime", "time", "input", "reg", "event"
						 }
						k==2: {
							LBRACK, "signed", "integer", "real", "realtime", 
							"time", "reg", STAR, IDENT, ESCAPED_IDENT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {LPAREN, "input" }
							k==2: {
								LBRACK, "signed", "integer", "real", "realtime", 
								"time", "reg", STAR, IDENT, ESCAPED_IDENT
							 }
						is matched, AND the syntactic predicate:
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ LPAREN, "input" }
									This block has a single alternative
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LPAREN, "input" }
									is matched.
									Start ZERO-OR-MORE (...)+ block:
										Start of an alternative block.
											The lookahead set for this block is:
												{ LPAREN }
											This block has a single alternative
											
											Alternate(1) will be taken IF:
											The lookahead set: 
												{ LPAREN }
											is matched.
											Rule Reference: attribute_instance
											
											OTHERWISE, a NoViableAlt exception will be thrown
											
										End of alternative block.
									End ZERO-OR-MORE block.
									Rule Reference: tf_input_declaration
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternative block.
						is matched.
						Start ZERO-OR-MORE (...)+ block:
							Start of an alternative block.
								The lookahead set for this block is:
									{ LPAREN }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ LPAREN }
								is matched.
								Rule Reference: attribute_instance
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						Rule Reference: tf_input_declaration, assigned to 'tpd'
						Match token SEMI
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {
								LPAREN, "localparam", "parameter", "integer", "real", 
								"realtime", "time", "reg", "event"
							 }
							k==2: {
								LBRACK, "signed", "integer", "real", "realtime", 
								"time", STAR, IDENT, ESCAPED_IDENT
							 }
						is matched.
						Rule Reference: block_item_declaration, assigned to 'bid'
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: fid = getTree().funcItemDecl(tpd,bid);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				POUND, LPAREN, LCURLY, "localparam", "parameter", 
				"integer", "real", "realtime", "time", "input", "reg", 
				"event", "for", "if", "case", "begin", "assign", 
				"deassign", "force", "release", "fork", "repeat", "disable", 
				AT, TRIGGER, "wait", "casex", "casez", "forever", 
				"while", IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME
			 }
	*** End Parser Rule: function_item_declaration
	
	
	*** Parser Rule: function_port_list
		Access: public
		Return value(s): ListOf<TfPortDeclaration> lop
		Init action:  lop=null; TfPortDeclaration tpd=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LPAREN, "input" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LPAREN, "input" }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LPAREN }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LPAREN }
					is matched.
					Rule Reference: attribute_instance
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Rule Reference: tf_input_declaration, assigned to 'tpd'
			ACTION: lop = getTree().addToList(lop,tpd);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Start ZERO-OR-MORE (...)+ block:
						Start of an alternative block.
							The lookahead set for this block is:
								{ LPAREN }
							This block has a single alternative
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ LPAREN }
							is matched.
							Rule Reference: attribute_instance
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternative block.
					End ZERO-OR-MORE block.
					Rule Reference: tf_input_declaration, assigned to 'tpd'
					ACTION: getTree().addToList(lop,tpd);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN }
	*** End Parser Rule: function_port_list
	
	
	*** Parser Rule: block_item_declaration
		Access: public
		Return value(s): BlockItemDecl bid
		Init action:  bid=null; int la=LA(1); boolean isSigned=false; Range rng=null;
		ListOf<BlockVariableType> lov=null; ListOf<BlockRealType> lor=null;
		EventDecl ed=null; LocalParameterDecl lpd=null; ParameterDeclaration pd=null;
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, "localparam", "parameter", "integer", "real", 
					"realtime", "time", "reg", "event"
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, "localparam", "parameter", "integer", "real", 
					"realtime", "time", "reg", "event"
				 }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LPAREN }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LPAREN }
					is matched.
					Rule Reference: attribute_instance
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"localparam", "parameter", "integer", "real", "realtime", 
							"time", "reg", "event"
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "reg" }
						is matched.
						Match string literal "reg"
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "signed" }
									is matched.
									Match string literal "signed"
									ACTION: isSigned=true;
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ LBRACK, IDENT, ESCAPED_IDENT }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LBRACK, IDENT, ESCAPED_IDENT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LBRACK }
									is matched.
									Rule Reference: range, assigned to 'rng'
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ IDENT, ESCAPED_IDENT }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Rule Reference: list_of_block_variable_identifiers, assigned to 'lov'
						Match token SEMI
						ACTION: bid = getTree().blockItemDecl(isSigned, rng, lov);
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "integer" }
						is matched.
						Match string literal "integer"
						Rule Reference: list_of_block_variable_identifiers, assigned to 'lov'
						Match token SEMI
						ACTION: bid = getTree().blockItemDecl(la, lov);
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ "time" }
						is matched.
						Match string literal "time"
						Rule Reference: list_of_block_variable_identifiers, assigned to 'lov'
						Match token SEMI
						ACTION: bid = getTree().blockItemDecl(la, lov);
						
						Otherwise, Alternate(4) will be taken IF:
						The lookahead set: 
							{ "real" }
						is matched.
						Match string literal "real"
						Rule Reference: list_of_block_real_identifiers, assigned to 'lor'
						Match token SEMI
						ACTION: bid = getTree().blockItemDecl(la, lor, true);
						
						Otherwise, Alternate(5) will be taken IF:
						The lookahead set: 
							{ "realtime" }
						is matched.
						Match string literal "realtime"
						Rule Reference: list_of_block_real_identifiers, assigned to 'lor'
						Match token SEMI
						ACTION: bid = getTree().blockItemDecl(la, lor, true);
						
						Otherwise, Alternate(6) will be taken IF:
						The lookahead set: 
							{ "event" }
						is matched.
						Rule Reference: event_declaration, assigned to 'ed'
						ACTION: bid = getTree().blockItemDecl(ed);
						
						Otherwise, Alternate(7) will be taken IF:
						The lookahead set: 
							{ "localparam" }
						is matched.
						Rule Reference: local_parameter_declaration, assigned to 'lpd'
						Match token SEMI
						ACTION: bid = getTree().blockItemDecl(lpd);
						
						Otherwise, Alternate(8) will be taken IF:
						The lookahead set: 
							{ "parameter" }
						is matched.
						Rule Reference: parameter_declaration, assigned to 'pd'
						Match token SEMI
						ACTION: bid = getTree().blockItemDecl(pd);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, POUND, LPAREN, LCURLY, "localparam", 
				"parameter", "integer", "real", "realtime", "time", "inout", 
				"input", "output", "reg", "event", "for", "if", 
				"case", "begin", "end", "assign", "deassign", "force", 
				"release", "fork", "join", "repeat", "disable", AT, 
				TRIGGER, "wait", "casex", "casez", "forever", "while", 
				IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME
			 }
	*** End Parser Rule: block_item_declaration
	
	
	*** Parser Rule: function_statement
		Access: public
		Return value(s): FuncStatement fc
		Init action:  fc=null; Statement st=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					POUND, LPAREN, LCURLY, "for", "if", 
					"case", "begin", "assign", "deassign", "force", "release", 
					"fork", "repeat", "disable", AT, TRIGGER, "wait", 
					"casex", "casez", "forever", "while", IDENT, ESCAPED_IDENT, 
					SYSTEM_TASK_NAME
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					POUND, LPAREN, LCURLY, "for", "if", 
					"case", "begin", "assign", "deassign", "force", "release", 
					"fork", "repeat", "disable", AT, TRIGGER, "wait", 
					"casex", "casez", "forever", "while", IDENT, ESCAPED_IDENT, 
					SYSTEM_TASK_NAME
				 }
			is matched.
			Rule Reference: statement, assigned to 'st'
			ACTION: fc = getTree().functionStatement(st);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {"endfunction" }
	*** End Parser Rule: function_statement
	
	
	*** Parser Rule: tf_input_declaration
		Access: public
		Return value(s): TfPortDeclaration tfp
		Init action:  tfp=null; int dir=LA(1); TaskPortType tpt=null; ListOf<PortIdent> lop=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "input" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "input" }
			is matched.
			Match string literal "input"
			Rule Reference: task_port_type, assigned to 'tpt'
			Rule Reference: list_of_port_identifiers, assigned to 'lop'
			ACTION: tfp = getTree().tfPortDecl(dir, tpt, lop);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN, COMMA }
	*** End Parser Rule: tf_input_declaration
	
	
	*** Parser Rule: task_identifier
		Access: public
		Return value(s): TaskIdent rid
		Init action:  rid=null; Ident id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'id'
			ACTION: rid = getTree().taskIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, LPAREN }
	*** End Parser Rule: task_identifier
	
	
	*** Parser Rule: task_item_declaration
		Access: public
		Return value(s): TaskItemDecl tid
		Init action:  tid=null; BlockItemDecl bid=null; TfPortDeclaration tpd=null;
		Error: This rule is non-deterministic
		Start of an alternative block.
			The lookahead set for this block is:
				k==1: {
					LPAREN, "localparam", "parameter", "integer", "real", 
					"realtime", "time", "inout", "input", "output", "reg", 
					"event"
				 }
				k==2: {
					LBRACK, "signed", "integer", "real", "realtime", 
					"time", "reg", STAR, IDENT, ESCAPED_IDENT
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					k==1: {
						LPAREN, "localparam", "parameter", "integer", "real", 
						"realtime", "time", "reg", "event"
					 }
					k==2: {
						LBRACK, "signed", "integer", "real", "realtime", 
						"time", STAR, IDENT, ESCAPED_IDENT
					 }
				is matched, AND the syntactic predicate:
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ 
									LPAREN, "localparam", "parameter", "integer", "real", 
									"realtime", "time", "reg", "event"
								 }
							This block has a single alternative
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ 
									LPAREN, "localparam", "parameter", "integer", "real", 
									"realtime", "time", "reg", "event"
								 }
							is matched.
							Rule Reference: block_item_declaration
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternative block.
				is matched.
				Rule Reference: block_item_declaration, assigned to 'bid'
				ACTION: tid = getTree().taskItemDecl(bid,null);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					k==1: {LPAREN, "inout", "input", "output" }
					k==2: {
						LBRACK, "signed", "integer", "real", "realtime", 
						"time", "reg", STAR, IDENT, ESCAPED_IDENT
					 }
				is matched.
				Start ZERO-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ LPAREN }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LPAREN }
						is matched.
						Rule Reference: attribute_instance
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ZERO-OR-MORE block.
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ "inout", "input", "output" }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ "input" }
							is matched.
							Rule Reference: tf_input_declaration, assigned to 'tpd'
							Match token SEMI
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ "output" }
							is matched.
							Rule Reference: tf_output_declaration, assigned to 'tpd'
							Match token SEMI
							
							Otherwise, Alternate(3) will be taken IF:
							The lookahead set: 
								{ "inout" }
							is matched.
							Rule Reference: tf_inout_declaration, assigned to 'tpd'
							Match token SEMI
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				ACTION: tid = getTree().taskItemDecl(null,tpd);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, POUND, LPAREN, LCURLY, "localparam", 
				"parameter", "integer", "real", "realtime", "time", "inout", 
				"input", "output", "reg", "event", "for", "if", 
				"case", "begin", "assign", "deassign", "force", "release", 
				"fork", "repeat", "disable", AT, TRIGGER, "wait", 
				"casex", "casez", "forever", "while", IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME
			 }
	*** End Parser Rule: task_item_declaration
	
	
	*** Parser Rule: task_port_list
		Access: public
		Return value(s): ListOf<TfPortDeclaration> lop
		Init action:  lop=null; TfPortDeclaration tpd=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LPAREN, "inout", "input", "output" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LPAREN, "inout", "input", "output" }
			is matched.
			Rule Reference: task_port_item, assigned to 'tpd'
			ACTION: lop = getTree().addToList(lop,tpd);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: task_port_item, assigned to 'tpd'
					ACTION: lop = getTree().addToList(lop,tpd);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN }
	*** End Parser Rule: task_port_list
	
	
	*** Parser Rule: statement_or_null
		Access: public
		Return value(s): Statement stmt
		Init action:  stmt=null;
		Error: This rule is non-deterministic
		Start of an alternative block.
			The lookahead set for this block is:
				k==1: {
					SEMI, POUND, LPAREN, LCURLY, "for", 
					"if", "case", "begin", "assign", "deassign", "force", 
					"release", "fork", "repeat", "disable", AT, TRIGGER, 
					"wait", "casex", "casez", "forever", "while", IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME
				 }
				k==2: {
					SEMI, "endmodule", POUND, LPAREN, DOT, 
					LCURLY, LBRACK, "defparam", "localparam", "parameter", "specparam", 
					"integer", "real", "realtime", "time", "inout", "input", 
					"output", "reg", "event", "supply0", "supply1", "tri", 
					"triand", "trior", "tri0", "tri1", "uwire", "wire", 
					"wand", "wor", ASSIGN, COLON, "function", "endfunction", 
					"task", "endtask", "generate", "endgenerate", "genvar", "for", 
					"if", "else", "case", "endcase", "default", "begin", 
					"end", "assign", "initial", "always", LE, "deassign", 
					"force", "release", "fork", "join", "repeat", "disable", 
					AT, STAR, TRIGGER, "or", "wait", "casex", 
					"casez", "forever", "while", NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", 
					"xnor", MINUS, PLUS, LNOT, BNOT, BAND, 
					RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					k==1: {SEMI, LPAREN }
					k==2: {
						"endmodule", POUND, LPAREN, LCURLY, "defparam", 
						"localparam", "parameter", "specparam", "integer", "real", "realtime", 
						"time", "inout", "input", "output", "reg", "event", 
						"supply0", "supply1", "tri", "triand", "trior", "tri0", 
						"tri1", "uwire", "wire", "wand", "wor", "function", 
						"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
						"for", "if", "else", "case", "endcase", "default", 
						"begin", "end", "assign", "initial", "always", "deassign", 
						"force", "release", "fork", "join", "repeat", "disable", 
						AT, STAR, TRIGGER, "or", "wait", "casex", 
						"casez", "forever", "while", NUMBER, STRING, IDENT, 
						ESCAPED_IDENT, SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", 
						"xnor", MINUS, PLUS, LNOT, BNOT, BAND, 
						RNAND, BOR, RNOR, BXOR, RXNOR
					 }
				is matched, AND the syntactic predicate:
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ SEMI, LPAREN }
							This block has a single alternative
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ SEMI, LPAREN }
							is matched.
							Start ZERO-OR-MORE (...)+ block:
								Start of an alternative block.
									The lookahead set for this block is:
										{ LPAREN }
									This block has a single alternative
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LPAREN }
									is matched.
									Rule Reference: attribute_instance
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternative block.
							End ZERO-OR-MORE block.
							Match token SEMI
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternative block.
				is matched.
				Start ZERO-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ LPAREN }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LPAREN }
						is matched.
						Rule Reference: attribute_instance
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ZERO-OR-MORE block.
				Match token SEMI
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					k==1: {
						POUND, LPAREN, LCURLY, "for", "if", 
						"case", "begin", "assign", "deassign", "force", "release", 
						"fork", "repeat", "disable", AT, TRIGGER, "wait", 
						"casex", "casez", "forever", "while", IDENT, ESCAPED_IDENT, 
						SYSTEM_TASK_NAME
					 }
					k==2: {
						SEMI, POUND, LPAREN, DOT, LCURLY, 
						LBRACK, ASSIGN, COLON, "for", "if", "case", 
						"begin", "end", "assign", LE, "deassign", "force", 
						"release", "fork", "join", "repeat", "disable", AT, 
						STAR, TRIGGER, "wait", "casex", "casez", "forever", 
						"while", NUMBER, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME
					 }
				is matched.
				Rule Reference: statement, assigned to 'stmt'
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", POUND, LPAREN, LCURLY, "defparam", 
				"localparam", "parameter", "specparam", "integer", "real", "realtime", 
				"time", "inout", "input", "output", "reg", "event", 
				"supply0", "supply1", "tri", "triand", "trior", "tri0", 
				"tri1", "uwire", "wire", "wand", "wor", "function", 
				"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
				"for", "if", "else", "case", "endcase", "default", 
				"begin", "end", "assign", "initial", "always", "deassign", 
				"force", "release", "fork", "join", "repeat", "disable", 
				AT, TRIGGER, "or", "wait", "casex", "casez", 
				"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: statement_or_null
	
	
	*** Parser Rule: tf_output_declaration
		Access: public
		Return value(s): TfPortDeclaration tfp
		Init action:  tfp=null; int dir=LA(1); TaskPortType tpt=null; ListOf<PortIdent> lop=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "output" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "output" }
			is matched.
			Match string literal "output"
			Rule Reference: task_port_type, assigned to 'tpt'
			Rule Reference: list_of_port_identifiers, assigned to 'lop'
			ACTION: tfp = getTree().tfPortDecl(dir, tpt, lop);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN, COMMA }
	*** End Parser Rule: tf_output_declaration
	
	
	*** Parser Rule: tf_inout_declaration
		Access: public
		Return value(s): TfPortDeclaration tfp
		Init action:  tfp=null; int dir=LA(1); TaskPortType tpt=null; ListOf<PortIdent> lop=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "inout" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "inout" }
			is matched.
			Match string literal "inout"
			Rule Reference: task_port_type, assigned to 'tpt'
			Rule Reference: list_of_port_identifiers, assigned to 'lop'
			ACTION: tfp = getTree().tfPortDecl(dir, tpt, lop);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN, COMMA }
	*** End Parser Rule: tf_inout_declaration
	
	
	*** Parser Rule: task_port_item
		Access: public
		Return value(s): TfPortDeclaration tpd
		Init action:  tpd=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LPAREN, "inout", "input", "output" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LPAREN, "inout", "input", "output" }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LPAREN }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LPAREN }
					is matched.
					Rule Reference: attribute_instance
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ "inout", "input", "output" }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "input" }
						is matched.
						Rule Reference: tf_input_declaration, assigned to 'tpd'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "output" }
						is matched.
						Rule Reference: tf_output_declaration, assigned to 'tpd'
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ "inout" }
						is matched.
						Rule Reference: tf_inout_declaration, assigned to 'tpd'
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN, COMMA }
	*** End Parser Rule: task_port_item
	
	
	*** Parser Rule: task_port_type
		Access: public
		Return value(s): TaskPortType tpt
		Init action:  tpt=null; int la=LA(1); boolean isReg=false;
		boolean isSigned=false; Range rng=null;
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LBRACK, "signed", "integer", "real", "realtime", 
					"time", "reg", IDENT, ESCAPED_IDENT
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ "integer", "real", "realtime", "time" }
				is matched.
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ "integer", "real", "realtime", "time" }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ "integer" }
							is matched.
							Match string literal "integer"
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ "real" }
							is matched.
							Match string literal "real"
							
							Otherwise, Alternate(3) will be taken IF:
							The lookahead set: 
								{ "realtime" }
							is matched.
							Match string literal "realtime"
							
							Otherwise, Alternate(4) will be taken IF:
							The lookahead set: 
								{ "time" }
							is matched.
							Match string literal "time"
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				ACTION: tpt = getTree().taskPortType(la);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ LBRACK, "signed", "reg", IDENT, ESCAPED_IDENT }
				is matched.
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ LBRACK, "signed", "reg", IDENT, ESCAPED_IDENT }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ "reg" }
							is matched.
							Match string literal "reg"
							ACTION: isReg=true;
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ LBRACK, "signed", IDENT, ESCAPED_IDENT }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ "signed" }
							is matched.
							Match string literal "signed"
							ACTION: isSigned=true;
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ LBRACK, IDENT, ESCAPED_IDENT }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ LBRACK, IDENT, ESCAPED_IDENT }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ LBRACK }
							is matched.
							Rule Reference: range, assigned to 'rng'
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ IDENT, ESCAPED_IDENT }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				ACTION: tpt = getTree().taskPortType(isReg, isSigned, rng);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {IDENT, ESCAPED_IDENT }
	*** End Parser Rule: task_port_type
	
	
	*** Parser Rule: list_of_block_variable_identifiers
		Access: public
		Return value(s): ListOf<BlockVariableType> lob
		Init action:  lob=null; BlockVariableType bvt=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: block_variable_type, assigned to 'bvt'
			ACTION: lob = getTree().addToList(lob,bvt);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: block_variable_type, assigned to 'bvt'
					ACTION: lob = getTree().addToList(lob,bvt);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: list_of_block_variable_identifiers
	
	
	*** Parser Rule: list_of_block_real_identifiers
		Access: public
		Return value(s): ListOf<BlockRealType> lob
		Init action:  lob=null; BlockRealType brt=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: block_real_type, assigned to 'brt'
			ACTION: lob = getTree().addToList(lob,brt);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: block_real_type, assigned to 'brt'
					ACTION: lob = getTree().addToList(lob,brt);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: list_of_block_real_identifiers
	
	
	*** Parser Rule: block_variable_type
		Access: public
		Return value(s): BlockVariableType bvt
		Init action:  bvt=null; VariableIdent id=null; Dimension dim=null; 
			ListOf<Dimension> lod=null;
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: variable_identifier, assigned to 'id'
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LBRACK }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LBRACK }
					is matched.
					Rule Reference: dimension, assigned to 'dim'
					ACTION: lod=getTree().addToList(lod,dim);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			ACTION: bvt = getTree().blockVariableType(id,lod);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA }
	*** End Parser Rule: block_variable_type
	
	
	*** Parser Rule: block_real_type
		Access: public
		Return value(s): BlockRealType brt
		Init action:  brt=null; RealIdent id=null; Dimension dim=null; ListOf<Dimension> lod=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: real_identifier, assigned to 'id'
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LBRACK }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LBRACK }
					is matched.
					Rule Reference: dimension, assigned to 'dim'
					ACTION: lod=getTree().addToList(lod,dim);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			ACTION: brt = getTree().blockRealType(id,lod);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA }
	*** End Parser Rule: block_real_type
	
	
	*** Parser Rule: parameter_value_assignment
		Access: public
		Return value(s): ParameterValueAssignment pva
		Init action:  pva=null; ListOf<ParameterAssignment> lopa=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ POUND }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ POUND }
			is matched.
			Match token POUND
			Match token LPAREN
			Rule Reference: list_of_parameter_assignments, assigned to 'lopa'
			Match token RPAREN
			ACTION: pva = getTree().parameterValueAssignment(lopa);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {LPAREN, IDENT, ESCAPED_IDENT }
	*** End Parser Rule: parameter_value_assignment
	
	
	*** Parser Rule: module_instance
		Access: public
		Return value(s): ModuleInstance inst
		Init action:  inst=null; ListOf<PortConnection> lopc=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LPAREN, IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LPAREN, IDENT, ESCAPED_IDENT }
			is matched.
			ACTION: inst = getTree().moduleInstance();
			Rule Reference: name_of_module_instance, arguments = inst
			Match token LPAREN
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {
							LPAREN, RPAREN, COMMA, DOT, LCURLY, 
							NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, 
							PLUS, LNOT, BNOT, BAND, RNAND, BOR, 
							RNOR, BXOR, RXNOR
						 }
						k==2: {
							SEMI, LPAREN, RPAREN, COMMA, DOT, 
							LCURLY, LBRACK, QMARK, LE, STAR, NUMBER, 
							STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
							LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
							BXOR, RXNOR, DIV, MOD, EQUAL, NOT_EQ, 
							NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, GT, 
							GE, SR, SL, SR3, SL3, STAR2
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {
								LPAREN, RPAREN, COMMA, DOT, LCURLY, 
								NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, 
								PLUS, LNOT, BNOT, BAND, RNAND, BOR, 
								RNOR, BXOR, RXNOR
							 }
							k==2: {
								SEMI, LPAREN, RPAREN, COMMA, DOT, 
								LCURLY, LBRACK, QMARK, LE, STAR, NUMBER, 
								STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
								LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
								BXOR, RXNOR, DIV, MOD, EQUAL, NOT_EQ, 
								NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, GT, 
								GE, SR, SL, SR3, SL3, STAR2
							 }
						is matched.
						Rule Reference: list_of_port_connections, assigned to 'lopc'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {RPAREN }
							k==2: {SEMI, COMMA }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Match token RPAREN
			ACTION: getTree().moduleInstance(inst,lopc);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA }
	*** End Parser Rule: module_instance
	
	
	*** Parser Rule: list_of_parameter_assignments
		Access: public
		Return value(s): ListOf<ParameterAssignment> lopa
		Init action:  lopa=null; Expression exp=null; NamedParamAssignment npa=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, DOT, LCURLY, NUMBER, STRING, 
					IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, 
					BNOT, BAND, RNAND, BOR, RNOR, BXOR, 
					RXNOR
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ 
						LPAREN, LCURLY, NUMBER, STRING, IDENT, 
						ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
						BAND, RNAND, BOR, RNOR, BXOR, RXNOR
					 }
				is matched.
				Rule Reference: ordered_parameter_assignment, assigned to 'exp'
				ACTION: lopa = getTree().listOfParamAssigns(lopa,exp,null);
				Start ZERO-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ COMMA }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ COMMA }
						is matched.
						Match token COMMA
						Rule Reference: ordered_parameter_assignment, assigned to 'exp'
						ACTION: getTree().listOfParamAssigns(lopa,exp,null);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ZERO-OR-MORE block.
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ DOT }
				is matched.
				Rule Reference: named_parameter_assignment, assigned to 'npa'
				ACTION: lopa = getTree().listOfParamAssigns(lopa,null,npa);
				Start ZERO-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ COMMA }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ COMMA }
						is matched.
						Match token COMMA
						Rule Reference: named_parameter_assignment, assigned to 'npa'
						ACTION: getTree().listOfParamAssigns(lopa,null,npa);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ZERO-OR-MORE block.
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN }
	*** End Parser Rule: list_of_parameter_assignments
	
	
	*** Parser Rule: ordered_parameter_assignment
		Access: public
		Return value(s): Expression exp
		Init action:  exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Rule Reference: expression, assigned to 'exp'
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN, COMMA }
	*** End Parser Rule: ordered_parameter_assignment
	
	
	*** Parser Rule: named_parameter_assignment
		Access: public
		Return value(s): NamedParamAssignment npa
		Init action:  npa=null; ParameterIdent id=null; MinTypMaxExpression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ DOT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ DOT }
			is matched.
			Match token DOT
			Rule Reference: parameter_identifier, assigned to 'id'
			Match token LPAREN
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							LPAREN, RPAREN, LCURLY, NUMBER, STRING, 
							IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, 
							BNOT, BAND, RNAND, BOR, RNOR, BXOR, 
							RXNOR
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR
							 }
						is matched.
						Rule Reference: mintypmax_expression, assigned to 'exp'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ RPAREN }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Match token RPAREN
			ACTION: npa = getTree().namedParameterAssignment(id,exp);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN, COMMA }
	*** End Parser Rule: named_parameter_assignment
	
	
	*** Parser Rule: mintypmax_expression
		Access: public
		Return value(s): MinTypMaxExpression mtm
		Init action:  mtm=null; Expression mtms[] = {null,null,null}; Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Rule Reference: expression, assigned to 'exp'
			ACTION: mtms[0]=exp;
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ RPAREN, COLON }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ COLON }
						is matched.
						Match token COLON
						Rule Reference: expression, assigned to 'exp'
						ACTION: mtms[1]=exp;
						Match token COLON
						Rule Reference: expression, assigned to 'exp'
						ACTION: mtms[2]=exp;
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ RPAREN }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: mtm=getTree().minTypMaxExpression(mtms);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN }
	*** End Parser Rule: mintypmax_expression
	
	
	*** Parser Rule: name_of_module_instance
		Access: public
		Return value: none
		Arguments: ModuleInstance inst
		Init action: 	ModuleInstanceIdent nm=null; Range rng=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LPAREN, IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LPAREN, IDENT, ESCAPED_IDENT }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ LPAREN, IDENT, ESCAPED_IDENT }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ IDENT, ESCAPED_IDENT }
						is matched.
						Rule Reference: module_instance_identifier, assigned to 'nm'
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ LPAREN, LBRACK }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LBRACK }
									is matched.
									Rule Reference: range, assigned to 'rng'
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ LPAREN }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ LPAREN }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: getTree().moduleInstance(inst, nm, rng);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {LPAREN }
	*** End Parser Rule: name_of_module_instance
	
	
	*** Parser Rule: list_of_port_connections
		Access: public
		Return value(s): ListOf<PortConnection> lopc
		Init action:  lopc=null; Expression exp=null; NamedPortConnection npc=null;
		Error: This rule is non-deterministic
		Start of an alternative block.
			The lookahead set for this block is:
				k==1: {
					LPAREN, RPAREN, COMMA, DOT, LCURLY, 
					NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, 
					PLUS, LNOT, BNOT, BAND, RNAND, BOR, 
					RNOR, BXOR, RXNOR
				 }
				k==2: {
					SEMI, LPAREN, RPAREN, COMMA, DOT, 
					LCURLY, LBRACK, QMARK, LE, STAR, NUMBER, 
					STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
					LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
					BXOR, RXNOR, DIV, MOD, EQUAL, NOT_EQ, 
					NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, GT, 
					GE, SR, SL, SR3, SL3, STAR2
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					k==1: {
						LPAREN, RPAREN, COMMA, LCURLY, NUMBER, 
						STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
						LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
						BXOR, RXNOR
					 }
					k==2: {
						SEMI, LPAREN, RPAREN, COMMA, DOT, 
						LCURLY, LBRACK, QMARK, LE, STAR, NUMBER, 
						STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
						LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
						BXOR, RXNOR, DIV, MOD, EQUAL, NOT_EQ, 
						NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, GT, 
						GE, SR, SL, SR3, SL3, STAR2
					 }
				is matched, AND the syntactic predicate:
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ 
									LPAREN, LCURLY, NUMBER, STRING, IDENT, 
									ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
									BAND, RNAND, BOR, RNOR, BXOR, RXNOR
								 }
							This block has a single alternative
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ 
									LPAREN, LCURLY, NUMBER, STRING, IDENT, 
									ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
									BAND, RNAND, BOR, RNOR, BXOR, RXNOR
								 }
							is matched.
							Rule Reference: ordered_port_connection
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternative block.
				is matched.
				Rule Reference: ordered_port_connection, assigned to 'exp'
				ACTION: lopc = getTree().listOfPortConnections(lopc, exp, null);
				Start ZERO-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ COMMA }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ COMMA }
						is matched.
						Match token COMMA
						Rule Reference: ordered_port_connection, assigned to 'exp'
						ACTION: lopc = getTree().listOfPortConnections(lopc, exp, null);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ZERO-OR-MORE block.
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					k==1: {LPAREN, DOT }
					k==2: {STAR, IDENT, ESCAPED_IDENT }
				is matched.
				Rule Reference: named_port_connection, assigned to 'npc'
				ACTION: lopc = getTree().listOfPortConnections(lopc, null, npc);
				Start ZERO-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ COMMA }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ COMMA }
						is matched.
						Match token COMMA
						Rule Reference: named_port_connection, assigned to 'npc'
						ACTION: lopc = getTree().listOfPortConnections(lopc, null, npc);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ZERO-OR-MORE block.
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN }
	*** End Parser Rule: list_of_port_connections
	
	
	*** Parser Rule: module_instance_identifier
		Access: public
		Return value(s): ModuleInstanceIdent rid
		Init action:  rid=null; Ident id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'id'
			ACTION: rid = getTree().moduleInstanceIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {LPAREN, LBRACK }
	*** End Parser Rule: module_instance_identifier
	
	
	*** Parser Rule: ordered_port_connection
		Access: public
		Return value(s): Expression exp
		Init action:  exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, RPAREN, COMMA, LCURLY, NUMBER, 
					STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
					LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
					BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, RPAREN, COMMA, LCURLY, NUMBER, 
					STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
					LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
					BXOR, RXNOR
				 }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Warning: This zero-or-more block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {LPAREN }
						k==2: {STAR }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						k==1: {LPAREN }
						k==2: {STAR }
					is matched.
					Rule Reference: attribute_instance
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							LPAREN, RPAREN, COMMA, LCURLY, NUMBER, 
							STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
							LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
							BXOR, RXNOR
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR
							 }
						is matched.
						Rule Reference: expression, assigned to 'exp'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ RPAREN, COMMA }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN, COMMA }
	*** End Parser Rule: ordered_port_connection
	
	
	*** Parser Rule: named_port_connection
		Access: public
		Return value(s): NamedPortConnection npc
		Init action:  npc=null; PortIdent pi=null; Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LPAREN, DOT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LPAREN, DOT }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LPAREN }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LPAREN }
					is matched.
					Rule Reference: attribute_instance
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match token DOT
			Rule Reference: port_identifier, assigned to 'pi'
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ LPAREN, RPAREN, COMMA }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LPAREN }
						is matched.
						Match token LPAREN
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										LPAREN, RPAREN, LCURLY, NUMBER, STRING, 
										IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, 
										BNOT, BAND, RNAND, BOR, RNOR, BXOR, 
										RXNOR
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ 
											LPAREN, LCURLY, NUMBER, STRING, IDENT, 
											ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
											BAND, RNAND, BOR, RNOR, BXOR, RXNOR
										 }
									is matched.
									Rule Reference: expression, assigned to 'exp'
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ RPAREN }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Match token RPAREN
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ RPAREN, COMMA }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: npc = getTree().namedPortConnection(pi, exp);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN, COMMA }
	*** End Parser Rule: named_port_connection
	
	
	*** Parser Rule: list_of_genvar_identifiers
		Access: public
		Return value(s): ListOf<GenvarIdent> loi
		Init action:  loi=null; GenvarIdent id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: genvar_identifier, assigned to 'id'
			ACTION: loi = getTree().addToList(loi, id);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: genvar_identifier, assigned to 'id'
					ACTION: getTree().addToList(loi, id);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: list_of_genvar_identifiers
	
	
	*** Parser Rule: genvar_identifier
		Access: public
		Return value(s): GenvarIdent rid
		Init action:  rid=null; Ident id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'id'
			ACTION: rid = getTree().genvarIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, RPAREN, COMMA, ASSIGN, COLON, 
				QMARK, LE, STAR, MINUS, PLUS, BAND, 
				BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
				NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
				GT, GE, SR, SL, SR3, SL3, 
				STAR2
			 }
	*** End Parser Rule: genvar_identifier
	
	
	*** Parser Rule: genvar_initialization
		Access: public
		Return value(s): GenvarInit gi
		Init action:  gi=null; GenvarIdent lhs=null; ConstExpression rhs=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: genvar_identifier, assigned to 'lhs'
			Match token ASSIGN
			Rule Reference: constant_expression, assigned to 'rhs'
			ACTION: gi = getTree().genvarInit(lhs,rhs);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: genvar_initialization
	
	
	*** Parser Rule: genvar_expression
		Access: public
		Return value(s): GenvarExpression ge
		Init action:  ge=null; Object e1=null, e2=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Rule Reference: genvar_expression_1, assigned to 'e1'
			Rule Reference: genvar_expression_2, assigned to 'e2'
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, RPAREN, COLON, QMARK, LE, 
				STAR, MINUS, PLUS, BAND, BOR, BXOR, 
				RXNOR, DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, 
				EQ_CASE, LAND, LOR, LT_, GT, GE, 
				SR, SL, SR3, SL3, STAR2
			 }
	*** End Parser Rule: genvar_expression
	
	
	*** Parser Rule: genvar_iteration
		Access: public
		Return value(s): GenvarIteration gi
		Init action:  gi=null; GenvarIdent gv=null; GenvarExpression ge=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: genvar_identifier, assigned to 'gv'
			Match token ASSIGN
			Rule Reference: genvar_expression, assigned to 'ge'
			ACTION: gi = getTree().genvarIteration(gv,ge);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN }
	*** End Parser Rule: genvar_iteration
	
	
	*** Parser Rule: generate_block
		Access: public
		Return value(s): GenerateBlock gb
		Init action:  gb=null; ModuleOrGenerateItem mi=null; GenerateBlockIdent bi=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, "defparam", "localparam", "integer", "real", 
					"realtime", "time", "reg", "event", "supply0", "supply1", 
					"tri", "triand", "trior", "tri0", "tri1", "uwire", 
					"wire", "wand", "wor", "function", "task", "genvar", 
					"for", "if", "case", "begin", "assign", "initial", 
					"always", "or", IDENT, ESCAPED_IDENT, "and", "nand", 
					"nor", "xor", "xnor"
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ 
						LPAREN, "defparam", "localparam", "integer", "real", 
						"realtime", "time", "reg", "event", "supply0", "supply1", 
						"tri", "triand", "trior", "tri0", "tri1", "uwire", 
						"wire", "wand", "wor", "function", "task", "genvar", 
						"for", "if", "case", "assign", "initial", "always", 
						"or", IDENT, ESCAPED_IDENT, "and", "nand", "nor", 
						"xor", "xnor"
					 }
				is matched.
				Rule Reference: module_or_generate_item, assigned to 'mi'
				ACTION: gb = getTree().generateBlock(bi,mi);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ "begin" }
				is matched.
				Match string literal "begin"
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								LPAREN, "defparam", "localparam", "integer", "real", 
								"realtime", "time", "reg", "event", "supply0", "supply1", 
								"tri", "triand", "trior", "tri0", "tri1", "uwire", 
								"wire", "wand", "wor", COLON, "function", "task", 
								"genvar", "for", "if", "case", "end", "assign", 
								"initial", "always", "or", IDENT, ESCAPED_IDENT, "and", 
								"nand", "nor", "xor", "xnor"
							 }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ COLON }
							is matched.
							Match token COLON
							Rule Reference: generate_block_identifier, assigned to 'bi'
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ 
									LPAREN, "defparam", "localparam", "integer", "real", 
									"realtime", "time", "reg", "event", "supply0", "supply1", 
									"tri", "triand", "trior", "tri0", "tri1", "uwire", 
									"wire", "wand", "wor", "function", "task", "genvar", 
									"for", "if", "case", "end", "assign", "initial", 
									"always", "or", IDENT, ESCAPED_IDENT, "and", "nand", 
									"nor", "xor", "xnor"
								 }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				ACTION: gb = getTree().generateBlock(bi,mi);
				Start ZERO-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								LPAREN, "defparam", "localparam", "integer", "real", 
								"realtime", "time", "reg", "event", "supply0", "supply1", 
								"tri", "triand", "trior", "tri0", "tri1", "uwire", 
								"wire", "wand", "wor", "function", "task", "genvar", 
								"for", "if", "case", "assign", "initial", "always", 
								"or", IDENT, ESCAPED_IDENT, "and", "nand", "nor", 
								"xor", "xnor"
							 }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								LPAREN, "defparam", "localparam", "integer", "real", 
								"realtime", "time", "reg", "event", "supply0", "supply1", 
								"tri", "triand", "trior", "tri0", "tri1", "uwire", 
								"wire", "wand", "wor", "function", "task", "genvar", 
								"for", "if", "case", "assign", "initial", "always", 
								"or", IDENT, ESCAPED_IDENT, "and", "nand", "nor", 
								"xor", "xnor"
							 }
						is matched.
						Rule Reference: module_or_generate_item, assigned to 'mi'
						ACTION: getTree().generateBlock(gb,mi);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ZERO-OR-MORE block.
				Match string literal "end"
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: generate_block
	
	
	*** Parser Rule: genvar_expression_1
		Access: public
		Return value(s): Object e1
		Init action:  e1=null; GenvarPrimary gp=null; UnaryOp uop=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							LPAREN, LCURLY, NUMBER, STRING, IDENT, 
							ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
							BAND, RNAND, BOR, RNOR, BXOR, RXNOR
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME
							 }
						is matched.
						Rule Reference: genvar_primary, assigned to 'gp'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								MINUS, PLUS, LNOT, BNOT, BAND, 
								RNAND, BOR, RNOR, BXOR, RXNOR
							 }
						is matched.
						Rule Reference: unary_operator, assigned to 'uop'
						Start ZERO-OR-MORE (...)+ block:
							Warning: This zero-or-more block is non-deterministic
							Start of an alternative block.
								The lookahead set for this block is:
									k==1: {LPAREN }
									k==2: {STAR }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									k==1: {LPAREN }
									k==2: {STAR }
								is matched.
								Rule Reference: attribute_instance
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						Rule Reference: genvar_primary, assigned to 'gp'
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: e1 = getTree().genvarExpression(uop,gp);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, RPAREN, COLON, QMARK, LE, 
				STAR, MINUS, PLUS, BAND, BOR, BXOR, 
				RXNOR, DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, 
				EQ_CASE, LAND, LOR, LT_, GT, GE, 
				SR, SL, SR3, SL3, STAR2
			 }
	*** End Parser Rule: genvar_expression_1
	
	
	*** Parser Rule: genvar_expression_2
		Access: public
		Return value(s): Object ge2
		Init action:  ge2=null; BinaryOp bop=null; GenvarExpression gv1=null, gv2=null;
		Object e2=null; boolean isNull = false;
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					SEMI, RPAREN, COLON, QMARK, LE, 
					STAR, MINUS, PLUS, BAND, BOR, BXOR, 
					RXNOR, DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, 
					EQ_CASE, LAND, LOR, LT_, GT, GE, 
					SR, SL, SR3, SL3, STAR2
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					SEMI, RPAREN, COLON, QMARK, LE, 
					STAR, MINUS, PLUS, BAND, BOR, BXOR, 
					RXNOR, DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, 
					EQ_CASE, LAND, LOR, LT_, GT, GE, 
					SR, SL, SR3, SL3, STAR2
				 }
			is matched.
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {
							SEMI, RPAREN, COLON, QMARK, LE, 
							STAR, MINUS, PLUS, BAND, BOR, BXOR, 
							RXNOR, DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, 
							EQ_CASE, LAND, LOR, LT_, GT, GE, 
							SR, SL, SR3, SL3, STAR2
						 }
						k==2: {
							LPAREN, LCURLY, "defparam", "localparam", "integer", 
							"real", "realtime", "time", "reg", "event", "supply0", 
							"supply1", "tri", "triand", "trior", "tri0", "tri1", 
							"uwire", "wire", "wand", "wor", "function", "task", 
							"genvar", "for", "if", "case", "begin", "assign", 
							"initial", "always", "or", NUMBER, STRING, IDENT, 
							ESCAPED_IDENT, SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", 
							"xnor", MINUS, PLUS, LNOT, BNOT, BAND, 
							RNAND, BOR, RNOR, BXOR, RXNOR
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {
								LE, STAR, MINUS, PLUS, BAND, 
								BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
								NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
								GT, GE, SR, SL, SR3, SL3, 
								STAR2
							 }
							k==2: {
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR
							 }
						is matched.
						Rule Reference: binary_operator, assigned to 'bop'
						Start ZERO-OR-MORE (...)+ block:
							Warning: This zero-or-more block is non-deterministic
							Start of an alternative block.
								The lookahead set for this block is:
									k==1: {LPAREN }
									k==2: {STAR }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									k==1: {LPAREN }
									k==2: {STAR }
								is matched.
								Rule Reference: attribute_instance
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						Rule Reference: genvar_expression, assigned to 'gv1'
						Rule Reference: genvar_expression_2, assigned to 'e2'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {QMARK }
							k==2: {
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR
							 }
						is matched.
						Match token QMARK
						Start ZERO-OR-MORE (...)+ block:
							Warning: This zero-or-more block is non-deterministic
							Start of an alternative block.
								The lookahead set for this block is:
									k==1: {LPAREN }
									k==2: {STAR }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									k==1: {LPAREN }
									k==2: {STAR }
								is matched.
								Rule Reference: attribute_instance
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						Rule Reference: genvar_expression, assigned to 'gv1'
						Match token COLON
						Rule Reference: genvar_expression, assigned to 'gv2'
						Rule Reference: genvar_expression_2, assigned to 'e2'
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							k==1: {
								SEMI, RPAREN, COLON, QMARK, LE, 
								STAR, MINUS, PLUS, BAND, BOR, BXOR, 
								RXNOR, DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, 
								EQ_CASE, LAND, LOR, LT_, GT, GE, 
								SR, SL, SR3, SL3, STAR2
							 }
							k==2: {
								LPAREN, LCURLY, "defparam", "localparam", "integer", 
								"real", "realtime", "time", "reg", "event", "supply0", 
								"supply1", "tri", "triand", "trior", "tri0", "tri1", 
								"uwire", "wire", "wand", "wor", "function", "task", 
								"genvar", "for", "if", "case", "begin", "assign", 
								"initial", "always", "or", NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", 
								"xnor", MINUS, PLUS, LNOT, BNOT, BAND, 
								RNAND, BOR, RNOR, BXOR, RXNOR
							 }
						is matched.
						ACTION: isNull=true;
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: ge2 = (isNull) ? null : getTree().genvarExpression(bop,gv1,gv2,e2);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, RPAREN, COLON, QMARK, LE, 
				STAR, MINUS, PLUS, BAND, BOR, BXOR, 
				RXNOR, DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, 
				EQ_CASE, LAND, LOR, LT_, GT, GE, 
				SR, SL, SR3, SL3, STAR2
			 }
	*** End Parser Rule: genvar_expression_2
	
	
	*** Parser Rule: genvar_primary
		Access: public
		Return value(s): GenvarPrimary gp
		Init action:  gp=null; ConstPrimary cp=null; GenvarIdent gi=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME
				 }
			is matched.
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {
							LPAREN, LCURLY, NUMBER, STRING, IDENT, 
							ESCAPED_IDENT, SYSTEM_TASK_NAME
						 }
						k==2: {
							SEMI, LPAREN, RPAREN, DOT, LCURLY, 
							LBRACK, COLON, QMARK, LE, STAR, NUMBER, 
							STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
							LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
							BXOR, RXNOR, DIV, MOD, EQUAL, NOT_EQ, 
							NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, GT, 
							GE, SR, SL, SR3, SL3, STAR2
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME
							 }
							k==2: {
								SEMI, LPAREN, RPAREN, DOT, LCURLY, 
								LBRACK, COLON, QMARK, LE, STAR, NUMBER, 
								STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
								LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
								BXOR, RXNOR, DIV, MOD, EQUAL, NOT_EQ, 
								NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, GT, 
								GE, SR, SL, SR3, SL3, STAR2
							 }
						is matched, AND the syntactic predicate:
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ 
											LPAREN, LCURLY, NUMBER, STRING, IDENT, 
											ESCAPED_IDENT, SYSTEM_TASK_NAME
										 }
									This block has a single alternative
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ 
											LPAREN, LCURLY, NUMBER, STRING, IDENT, 
											ESCAPED_IDENT, SYSTEM_TASK_NAME
										 }
									is matched.
									Rule Reference: constant_primary
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternative block.
						is matched.
						Rule Reference: constant_primary, assigned to 'cp'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {IDENT, ESCAPED_IDENT }
							k==2: {
								SEMI, RPAREN, COLON, QMARK, LE, 
								STAR, MINUS, PLUS, BAND, BOR, BXOR, 
								RXNOR, DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, 
								EQ_CASE, LAND, LOR, LT_, GT, GE, 
								SR, SL, SR3, SL3, STAR2
							 }
						is matched.
						Rule Reference: genvar_identifier, assigned to 'gi'
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: gp = getTree().genvarPrimary(cp,gi);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, RPAREN, COLON, QMARK, LE, 
				STAR, MINUS, PLUS, BAND, BOR, BXOR, 
				RXNOR, DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, 
				EQ_CASE, LAND, LOR, LT_, GT, GE, 
				SR, SL, SR3, SL3, STAR2
			 }
	*** End Parser Rule: genvar_primary
	
	
	*** Parser Rule: unary_operator
		Access: public
		Return value(s): UnaryOp rop
		Init action: 	rop=null; int op=LA(1);
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					MINUS, PLUS, LNOT, BNOT, BAND, 
					RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					MINUS, PLUS, LNOT, BNOT, BAND, 
					RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							MINUS, PLUS, LNOT, BNOT, BAND, 
							RNAND, BOR, RNOR, BXOR, RXNOR
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ MINUS }
						is matched.
						Match token MINUS
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ PLUS }
						is matched.
						Match token PLUS
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ LNOT }
						is matched.
						Match token LNOT
						
						Otherwise, Alternate(4) will be taken IF:
						The lookahead set: 
							{ BNOT }
						is matched.
						Match token BNOT
						
						Otherwise, Alternate(5) will be taken IF:
						The lookahead set: 
							{ BAND }
						is matched.
						Match token BAND
						
						Otherwise, Alternate(6) will be taken IF:
						The lookahead set: 
							{ RNAND }
						is matched.
						Match token RNAND
						
						Otherwise, Alternate(7) will be taken IF:
						The lookahead set: 
							{ BOR }
						is matched.
						Match token BOR
						
						Otherwise, Alternate(8) will be taken IF:
						The lookahead set: 
							{ RNOR }
						is matched.
						Match token RNOR
						
						Otherwise, Alternate(9) will be taken IF:
						The lookahead set: 
							{ BXOR }
						is matched.
						Match token BXOR
						
						Otherwise, Alternate(10) will be taken IF:
						The lookahead set: 
							{ RXNOR }
						is matched.
						Match token RXNOR
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: rop = getTree().unaryOp(op);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				LPAREN, LCURLY, NUMBER, STRING, IDENT, 
				ESCAPED_IDENT, SYSTEM_TASK_NAME
			 }
	*** End Parser Rule: unary_operator
	
	
	*** Parser Rule: binary_operator
		Access: public
		Return value(s): BinaryOp rop
		Init action: 	rop=null; int op=LA(1);
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LE, STAR, MINUS, PLUS, BAND, 
					BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
					NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
					GT, GE, SR, SL, SR3, SL3, 
					STAR2
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LE, STAR, MINUS, PLUS, BAND, 
					BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
					NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
					GT, GE, SR, SL, SR3, SL3, 
					STAR2
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							LE, STAR, MINUS, PLUS, BAND, 
							BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
							NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
							GT, GE, SR, SL, SR3, SL3, 
							STAR2
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ MINUS }
						is matched.
						Match token MINUS
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ PLUS }
						is matched.
						Match token PLUS
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ BAND }
						is matched.
						Match token BAND
						
						Otherwise, Alternate(4) will be taken IF:
						The lookahead set: 
							{ BOR }
						is matched.
						Match token BOR
						
						Otherwise, Alternate(5) will be taken IF:
						The lookahead set: 
							{ BXOR }
						is matched.
						Match token BXOR
						
						Otherwise, Alternate(6) will be taken IF:
						The lookahead set: 
							{ RXNOR }
						is matched.
						Match token RXNOR
						
						Otherwise, Alternate(7) will be taken IF:
						The lookahead set: 
							{ STAR }
						is matched.
						Match token STAR
						
						Otherwise, Alternate(8) will be taken IF:
						The lookahead set: 
							{ DIV }
						is matched.
						Match token DIV
						
						Otherwise, Alternate(9) will be taken IF:
						The lookahead set: 
							{ MOD }
						is matched.
						Match token MOD
						
						Otherwise, Alternate(10) will be taken IF:
						The lookahead set: 
							{ EQUAL }
						is matched.
						Match token EQUAL
						
						Otherwise, Alternate(11) will be taken IF:
						The lookahead set: 
							{ NOT_EQ }
						is matched.
						Match token NOT_EQ
						
						Otherwise, Alternate(12) will be taken IF:
						The lookahead set: 
							{ NOT_EQ_CASE }
						is matched.
						Match token NOT_EQ_CASE
						
						Otherwise, Alternate(13) will be taken IF:
						The lookahead set: 
							{ EQ_CASE }
						is matched.
						Match token EQ_CASE
						
						Otherwise, Alternate(14) will be taken IF:
						The lookahead set: 
							{ LAND }
						is matched.
						Match token LAND
						
						Otherwise, Alternate(15) will be taken IF:
						The lookahead set: 
							{ LOR }
						is matched.
						Match token LOR
						
						Otherwise, Alternate(16) will be taken IF:
						The lookahead set: 
							{ LT_ }
						is matched.
						Match token LT_
						
						Otherwise, Alternate(17) will be taken IF:
						The lookahead set: 
							{ LE }
						is matched.
						Match token LE
						
						Otherwise, Alternate(18) will be taken IF:
						The lookahead set: 
							{ GT }
						is matched.
						Match token GT
						
						Otherwise, Alternate(19) will be taken IF:
						The lookahead set: 
							{ GE }
						is matched.
						Match token GE
						
						Otherwise, Alternate(20) will be taken IF:
						The lookahead set: 
							{ SR }
						is matched.
						Match token SR
						
						Otherwise, Alternate(21) will be taken IF:
						The lookahead set: 
							{ SL }
						is matched.
						Match token SL
						
						Otherwise, Alternate(22) will be taken IF:
						The lookahead set: 
							{ SR3 }
						is matched.
						Match token SR3
						
						Otherwise, Alternate(23) will be taken IF:
						The lookahead set: 
							{ SL3 }
						is matched.
						Match token SL3
						
						Otherwise, Alternate(24) will be taken IF:
						The lookahead set: 
							{ STAR2 }
						is matched.
						Match token STAR2
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: rop = getTree().binaryOp(op);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				LPAREN, LCURLY, NUMBER, STRING, IDENT, 
				ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
				BAND, RNAND, BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: binary_operator
	
	
	*** Parser Rule: constant_primary
		Access: public
		Return value(s): ConstPrimary cp
		Init action:  cp=null; Primary p=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME
				 }
			is matched.
			Rule Reference: primary, assigned to 'p'
			ACTION: cp = getTree().constantPrimary(p);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, RPAREN, COLON, QMARK, LE, 
				STAR, MINUS, PLUS, BAND, BOR, BXOR, 
				RXNOR, DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, 
				EQ_CASE, LAND, LOR, LT_, GT, GE, 
				SR, SL, SR3, SL3, STAR2
			 }
	*** End Parser Rule: constant_primary
	
	
	*** Parser Rule: if_generate_construct
		Access: public
		Return value(s): IfGenerateConstruct igs
		Init action:  igs=null; ConstExpression ifExpr=null; GenerateBlock ifb=null, elb=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "if" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "if" }
			is matched.
			Match string literal "if"
			Match token LPAREN
			Rule Reference: constant_expression, assigned to 'ifExpr'
			Match token RPAREN
			Rule Reference: generate_block_or_null, assigned to 'ifb'
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {
							"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
							"parameter", "specparam", "integer", "real", "realtime", "time", 
							"inout", "input", "output", "reg", "event", "supply0", 
							"supply1", "tri", "triand", "trior", "tri0", "tri1", 
							"uwire", "wire", "wand", "wor", "function", "task", 
							"generate", "endgenerate", "genvar", "for", "if", "else", 
							"case", "endcase", "default", "end", "assign", "initial", 
							"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
							SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
							MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
							BOR, RNOR, BXOR, RXNOR
						 }
						k==2: {
							EOF, SEMI, "endmodule", "module", "macromodule", 
							POUND, LPAREN, COMMA, DOT, LCURLY, LBRACK, 
							"defparam", "localparam", "signed", "parameter", "specparam", "integer", 
							"real", "realtime", "time", "inout", "input", "output", 
							"reg", "event", "vectored", "scalared", "supply0", "supply1", 
							"tri", "triand", "trior", "tri0", "tri1", "uwire", 
							"wire", "wand", "wor", COLON, "function", "automatic", 
							"task", "generate", "endgenerate", "genvar", "for", QMARK, 
							"if", "else", "case", "endcase", "default", "begin", 
							"end", "assign", "initial", "always", LE, "deassign", 
							"force", "release", "fork", "repeat", "disable", AT, 
							STAR, TRIGGER, "or", "wait", "casex", "casez", 
							"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
							SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
							MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
							BOR, RNOR, BXOR, RXNOR, DIV, MOD, 
							EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, 
							LT_, GT, GE, SR, SL, SR3, 
							SL3, STAR2
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {"else" }
							k==2: {
								SEMI, LPAREN, "defparam", "localparam", "integer", 
								"real", "realtime", "time", "reg", "event", "supply0", 
								"supply1", "tri", "triand", "trior", "tri0", "tri1", 
								"uwire", "wire", "wand", "wor", "function", "task", 
								"genvar", "for", "if", "case", "begin", "assign", 
								"initial", "always", "or", IDENT, ESCAPED_IDENT, "and", 
								"nand", "nor", "xor", "xnor"
							 }
						is matched.
						Match string literal "else"
						Rule Reference: generate_block_or_null, assigned to 'elb'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {
								"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
								"parameter", "specparam", "integer", "real", "realtime", "time", 
								"inout", "input", "output", "reg", "event", "supply0", 
								"supply1", "tri", "triand", "trior", "tri0", "tri1", 
								"uwire", "wire", "wand", "wor", "function", "task", 
								"generate", "endgenerate", "genvar", "for", "if", "else", 
								"case", "endcase", "default", "end", "assign", "initial", 
								"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
								SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
								MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
								BOR, RNOR, BXOR, RXNOR
							 }
							k==2: {
								EOF, SEMI, "endmodule", "module", "macromodule", 
								POUND, LPAREN, COMMA, DOT, LCURLY, LBRACK, 
								"defparam", "localparam", "signed", "parameter", "specparam", "integer", 
								"real", "realtime", "time", "inout", "input", "output", 
								"reg", "event", "vectored", "scalared", "supply0", "supply1", 
								"tri", "triand", "trior", "tri0", "tri1", "uwire", 
								"wire", "wand", "wor", COLON, "function", "automatic", 
								"task", "generate", "endgenerate", "genvar", "for", QMARK, 
								"if", "else", "case", "endcase", "default", "begin", 
								"end", "assign", "initial", "always", LE, "deassign", 
								"force", "release", "fork", "repeat", "disable", AT, 
								STAR, TRIGGER, "or", "wait", "casex", "casez", 
								"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
								SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
								MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
								BOR, RNOR, BXOR, RXNOR, DIV, MOD, 
								EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, 
								LT_, GT, GE, SR, SL, SR3, 
								SL3, STAR2
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: igs = getTree().ifGenerateConstruct(ifExpr, ifb, elb);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: if_generate_construct
	
	
	*** Parser Rule: case_generate_construct
		Access: public
		Return value(s): CaseGenerateConstruct cgc
		Init action:  cgc=null; ConstExpression ce=null; CaseGenerateItem cgi=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "case" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "case" }
			is matched.
			Match string literal "case"
			Match token LPAREN
			Rule Reference: constant_expression, assigned to 'ce'
			Match token RPAREN
			ACTION: cgc = getTree().caseGenerateConstruct(cgc,ce,null);
			Rule Reference: case_generate_item, assigned to 'cgi'
			ACTION: getTree().caseGenerateConstruct(cgc,null,cgi);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							LPAREN, LCURLY, "default", NUMBER, STRING, 
							IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, 
							BNOT, BAND, RNAND, BOR, RNOR, BXOR, 
							RXNOR
						 }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ 
							LPAREN, LCURLY, "default", NUMBER, STRING, 
							IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, 
							BNOT, BAND, RNAND, BOR, RNOR, BXOR, 
							RXNOR
						 }
					is matched.
					Rule Reference: case_generate_item, assigned to 'cgi'
					ACTION: getTree().caseGenerateConstruct(cgc,null,cgi);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match string literal "endcase"
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: case_generate_construct
	
	
	*** Parser Rule: generate_block_or_null
		Access: public
		Return value(s): GenerateBlock gb
		Init action:  gb=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					SEMI, LPAREN, "defparam", "localparam", "integer", 
					"real", "realtime", "time", "reg", "event", "supply0", 
					"supply1", "tri", "triand", "trior", "tri0", "tri1", 
					"uwire", "wire", "wand", "wor", "function", "task", 
					"genvar", "for", "if", "case", "begin", "assign", 
					"initial", "always", "or", IDENT, ESCAPED_IDENT, "and", 
					"nand", "nor", "xor", "xnor"
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ 
						LPAREN, "defparam", "localparam", "integer", "real", 
						"realtime", "time", "reg", "event", "supply0", "supply1", 
						"tri", "triand", "trior", "tri0", "tri1", "uwire", 
						"wire", "wand", "wor", "function", "task", "genvar", 
						"for", "if", "case", "begin", "assign", "initial", 
						"always", "or", IDENT, ESCAPED_IDENT, "and", "nand", 
						"nor", "xor", "xnor"
					 }
				is matched.
				Rule Reference: generate_block, assigned to 'gb'
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ SEMI }
				is matched.
				Match token SEMI
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", LPAREN, LCURLY, "defparam", "localparam", 
				"parameter", "specparam", "integer", "real", "realtime", "time", 
				"inout", "input", "output", "reg", "event", "supply0", 
				"supply1", "tri", "triand", "trior", "tri0", "tri1", 
				"uwire", "wire", "wand", "wor", "function", "task", 
				"generate", "endgenerate", "genvar", "for", "if", "else", 
				"case", "endcase", "default", "end", "assign", "initial", 
				"always", "or", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: generate_block_or_null
	
	
	*** Parser Rule: case_generate_item
		Access: public
		Return value(s): CaseGenerateItem cgi
		Init action:  cgi=null; ConstExpression ce=null; GenerateBlock gb=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, "default", NUMBER, STRING, 
					IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, 
					BNOT, BAND, RNAND, BOR, RNOR, BXOR, 
					RXNOR
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ 
						LPAREN, LCURLY, NUMBER, STRING, IDENT, 
						ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
						BAND, RNAND, BOR, RNOR, BXOR, RXNOR
					 }
				is matched.
				Rule Reference: constant_expression, assigned to 'ce'
				ACTION: cgi = getTree().caseGenerateItem(null,ce,null);
				Start ZERO-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ COMMA }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ COMMA }
						is matched.
						Match token COMMA
						Rule Reference: constant_expression, assigned to 'ce'
						ACTION: getTree().caseGenerateItem(cgi,ce,null);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ZERO-OR-MORE block.
				Match token COLON
				Rule Reference: generate_block_or_null, assigned to 'gb'
				ACTION: getTree().caseGenerateItem(cgi,null,gb);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ "default" }
				is matched.
				Match string literal "default"
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								SEMI, LPAREN, "defparam", "localparam", "integer", 
								"real", "realtime", "time", "reg", "event", "supply0", 
								"supply1", "tri", "triand", "trior", "tri0", "tri1", 
								"uwire", "wire", "wand", "wor", COLON, "function", 
								"task", "genvar", "for", "if", "case", "begin", 
								"assign", "initial", "always", "or", IDENT, ESCAPED_IDENT, 
								"and", "nand", "nor", "xor", "xnor"
							 }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ COLON }
							is matched.
							Match token COLON
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ 
									SEMI, LPAREN, "defparam", "localparam", "integer", 
									"real", "realtime", "time", "reg", "event", "supply0", 
									"supply1", "tri", "triand", "trior", "tri0", "tri1", 
									"uwire", "wire", "wand", "wor", "function", "task", 
									"genvar", "for", "if", "case", "begin", "assign", 
									"initial", "always", "or", IDENT, ESCAPED_IDENT, "and", 
									"nand", "nor", "xor", "xnor"
								 }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				Rule Reference: generate_block_or_null, assigned to 'gb'
				ACTION: cgi = getTree().caseGenerateItem(null,null,gb);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				LPAREN, LCURLY, "endcase", "default", NUMBER, 
				STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
				LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
				BXOR, RXNOR
			 }
	*** End Parser Rule: case_generate_item
	
	
	*** Parser Rule: generate_block_identifier
		Access: public
		Return value(s): GenerateBlockIdent rid
		Init action:  rid=null; Ident id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'id'
			ACTION: rid = getTree().generateBlockIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				LPAREN, "defparam", "localparam", "integer", "real", 
				"realtime", "time", "reg", "event", "supply0", "supply1", 
				"tri", "triand", "trior", "tri0", "tri1", "uwire", 
				"wire", "wand", "wor", "function", "task", "genvar", 
				"for", "if", "case", "end", "assign", "initial", 
				"always", "or", IDENT, ESCAPED_IDENT, "and", "nand", 
				"nor", "xor", "xnor"
			 }
	*** End Parser Rule: generate_block_identifier
	
	
	*** Parser Rule: list_of_net_assignments
		Access: public
		Return value(s): ListOf<NetAssign> lo
		Init action:  lo=null; NetAssign na=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LCURLY, IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LCURLY, IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: net_assignment, assigned to 'na'
			ACTION: lo = getTree().addToList(lo, na);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: net_assignment, assigned to 'na'
					ACTION: getTree().addToList(lo, na);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: list_of_net_assignments
	
	
	*** Parser Rule: net_assignment
		Access: public
		Return value(s): NetAssign na
		Init action:  na=null; Lvalue lv=null;  Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LCURLY, IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LCURLY, IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: lvalue, assigned to 'lv'
			Match token ASSIGN
			Rule Reference: expression, assigned to 'exp'
			ACTION: na = getTree().netAssignment(lv,exp);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA }
	*** End Parser Rule: net_assignment
	
	
	*** Parser Rule: lvalue
		Access: public
		Return value(s): Lvalue lv
		Init action:  lv=null; Object o1=null; Lvalue olv=null; ListOf<Lvalue> lof=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LCURLY, IDENT, ESCAPED_IDENT }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ IDENT, ESCAPED_IDENT }
				is matched.
				Rule Reference: lvalue2, assigned to 'o1'
				ACTION: lv  = getTree().lvalue(o1);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ LCURLY }
				is matched.
				Match token LCURLY
				Rule Reference: lvalue, assigned to 'olv'
				ACTION: lof = getTree().lvalue(lof, olv);
				Start ZERO-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ COMMA }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ COMMA }
						is matched.
						Match token COMMA
						Rule Reference: lvalue, assigned to 'olv'
						ACTION: getTree().lvalue(lof, olv);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ZERO-OR-MORE block.
				Match token RCURLY
				ACTION: lv = getTree().lvalue(lof);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA, RCURLY, ASSIGN, LE }
	*** End Parser Rule: lvalue
	
	
	*** Parser Rule: statement
		Access: public
		Return value(s): Statement stmt
		Init action:  stmt=null; Object o1=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					POUND, LPAREN, LCURLY, "for", "if", 
					"case", "begin", "assign", "deassign", "force", "release", 
					"fork", "repeat", "disable", AT, TRIGGER, "wait", 
					"casex", "casez", "forever", "while", IDENT, ESCAPED_IDENT, 
					SYSTEM_TASK_NAME
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					POUND, LPAREN, LCURLY, "for", "if", 
					"case", "begin", "assign", "deassign", "force", "release", 
					"fork", "repeat", "disable", AT, TRIGGER, "wait", 
					"casex", "casez", "forever", "while", IDENT, ESCAPED_IDENT, 
					SYSTEM_TASK_NAME
				 }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LPAREN }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LPAREN }
					is matched.
					Rule Reference: attribute_instance
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {
							POUND, LCURLY, "for", "if", "case", 
							"begin", "assign", "deassign", "force", "release", "fork", 
							"repeat", "disable", AT, TRIGGER, "wait", "casex", 
							"casez", "forever", "while", IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME
						 }
						k==2: {
							SEMI, POUND, LPAREN, DOT, LCURLY, 
							LBRACK, ASSIGN, COLON, "for", "if", "case", 
							"begin", "end", "assign", LE, "deassign", "force", 
							"release", "fork", "join", "repeat", "disable", AT, 
							STAR, TRIGGER, "wait", "casex", "casez", "forever", 
							"while", NUMBER, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {LCURLY, IDENT, ESCAPED_IDENT }
							k==2: {
								DOT, LCURLY, LBRACK, ASSIGN, IDENT, 
								ESCAPED_IDENT
							 }
						is matched, AND the syntactic predicate:
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ LCURLY, IDENT, ESCAPED_IDENT }
									This block has a single alternative
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LCURLY, IDENT, ESCAPED_IDENT }
									is matched.
									Rule Reference: blocking_assignment
									Match token SEMI
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternative block.
						is matched.
						Rule Reference: blocking_assignment, assigned to 'o1'
						Match token SEMI
						ACTION: stmt = getTree().statement((BlockingAssign)o1);
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "case", "casex", "casez" }
						is matched.
						Rule Reference: case_statement, assigned to 'o1'
						ACTION: stmt = getTree().statement((CaseStatement)o1);
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ "if" }
						is matched.
						Rule Reference: conditional_statement, assigned to 'o1'
						ACTION: stmt = getTree().statement((ConditionalStatement)o1);
						
						Otherwise, Alternate(4) will be taken IF:
						The lookahead set: 
							{ "disable" }
						is matched.
						Rule Reference: disable_statement, assigned to 'o1'
						ACTION: stmt = getTree().statement((DisableStmt)o1);
						
						Otherwise, Alternate(5) will be taken IF:
						The lookahead set: 
							{ TRIGGER }
						is matched.
						Rule Reference: event_trigger, assigned to 'o1'
						ACTION: stmt = getTree().statement((EventTrigger)o1);
						
						Otherwise, Alternate(6) will be taken IF:
						The lookahead set: 
							{ "for", "repeat", "forever", "while" }
						is matched.
						Rule Reference: loop_statement, assigned to 'o1'
						ACTION: stmt = getTree().statement((LoopStatement)o1);
						
						Otherwise, Alternate(7) will be taken IF:
						The lookahead set: 
							k==1: {LCURLY, IDENT, ESCAPED_IDENT }
							k==2: {
								DOT, LCURLY, LBRACK, LE, IDENT, 
								ESCAPED_IDENT
							 }
						is matched.
						Rule Reference: nonblocking_assignment, assigned to 'o1'
						Match token SEMI
						ACTION: stmt = getTree().statement((NonBlockingAssign)o1);
						
						Otherwise, Alternate(8) will be taken IF:
						The lookahead set: 
							{ "fork" }
						is matched.
						Rule Reference: par_block, assigned to 'o1'
						ACTION: stmt = getTree().statement((ParBlock)o1);
						
						Otherwise, Alternate(9) will be taken IF:
						The lookahead set: 
							{ "assign", "deassign", "force", "release" }
						is matched.
						Rule Reference: procedural_continuous_assignments, assigned to 'o1'
						Match token SEMI
						ACTION: stmt = getTree().statement((ProceduralContinuousAssign)o1);
						
						Otherwise, Alternate(10) will be taken IF:
						The lookahead set: 
							{ POUND, AT }
						is matched.
						Rule Reference: procedural_timing_control_statement, assigned to 'o1'
						ACTION: stmt = getTree().statement((ProceduralTimingControlStatement)o1);
						
						Otherwise, Alternate(11) will be taken IF:
						The lookahead set: 
							{ "begin" }
						is matched.
						Rule Reference: seq_block, assigned to 'o1'
						ACTION: stmt = getTree().statement((SeqBlock)o1);
						
						Otherwise, Alternate(12) will be taken IF:
						The lookahead set: 
							{ SYSTEM_TASK_NAME }
						is matched.
						Rule Reference: system_task_enable, assigned to 'o1'
						ACTION: stmt = getTree().statement((SystemTaskEnable)o1);
						
						Otherwise, Alternate(13) will be taken IF:
						The lookahead set: 
							k==1: {IDENT, ESCAPED_IDENT }
							k==2: {SEMI, LPAREN, DOT, LBRACK }
						is matched.
						Rule Reference: task_enable, assigned to 'o1'
						ACTION: stmt = getTree().statement((TaskEnable)o1);
						
						Otherwise, Alternate(14) will be taken IF:
						The lookahead set: 
							{ "wait" }
						is matched.
						Rule Reference: wait_statement, assigned to 'o1'
						ACTION: stmt = getTree().statement((WaitStatement)o1);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", POUND, LPAREN, LCURLY, "defparam", 
				"localparam", "parameter", "specparam", "integer", "real", "realtime", 
				"time", "inout", "input", "output", "reg", "event", 
				"supply0", "supply1", "tri", "triand", "trior", "tri0", 
				"tri1", "uwire", "wire", "wand", "wor", "function", 
				"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
				"for", "if", "else", "case", "endcase", "default", 
				"begin", "end", "assign", "initial", "always", "deassign", 
				"force", "release", "fork", "join", "repeat", "disable", 
				AT, TRIGGER, "or", "wait", "casex", "casez", 
				"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: statement
	
	
	*** Parser Rule: blocking_assignment
		Access: public
		Return value(s): BlockingAssign ba
		Init action:  ba=null; Lvalue lv=null; DelayOrEventControl dec=null; Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LCURLY, IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LCURLY, IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: lvalue, assigned to 'lv'
			Match token ASSIGN
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							POUND, LPAREN, LCURLY, "repeat", AT, 
							NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, 
							PLUS, LNOT, BNOT, BAND, RNAND, BOR, 
							RNOR, BXOR, RXNOR
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ POUND, "repeat", AT }
						is matched.
						Rule Reference: delay_or_event_control, assigned to 'dec'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: expression, assigned to 'exp'
			ACTION: ba = getTree().blockingAssignment(lv,dec,exp);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: blocking_assignment
	
	
	*** Parser Rule: delay_or_event_control
		Access: public
		Return value(s): DelayOrEventControl dec
		Init action:  dec=null; DelayControl dc=null; EventControl ec=null; Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ POUND, "repeat", AT }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ POUND }
				is matched.
				Rule Reference: delay_control, assigned to 'dc'
				ACTION: dec = getTree().delayOrEventControl(dc);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ AT }
				is matched.
				Rule Reference: event_control, assigned to 'ec'
				ACTION: dec = getTree().delayOrEventControl(ec);
				
				Otherwise, Alternate(3) will be taken IF:
				The lookahead set: 
					{ "repeat" }
				is matched.
				Match string literal "repeat"
				Match token LPAREN
				Rule Reference: expression, assigned to 'exp'
				Match token RPAREN
				Rule Reference: event_control, assigned to 'ec'
				ACTION: dec = getTree().delayOrEventControl(exp,ec);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				LPAREN, LCURLY, NUMBER, STRING, IDENT, 
				ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
				BAND, RNAND, BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: delay_or_event_control
	
	
	*** Parser Rule: nonblocking_assignment
		Access: public
		Return value(s): NonBlockingAssign nba
		Init action:  nba=null; Lvalue lv=null; DelayOrEventControl dec=null; Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LCURLY, IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LCURLY, IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: lvalue, assigned to 'lv'
			Match token LE
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							POUND, LPAREN, LCURLY, "repeat", AT, 
							NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, 
							PLUS, LNOT, BNOT, BAND, RNAND, BOR, 
							RNOR, BXOR, RXNOR
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ POUND, "repeat", AT }
						is matched.
						Rule Reference: delay_or_event_control, assigned to 'dec'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: expression, assigned to 'exp'
			ACTION: nba = getTree().nonBlockingAssignment(lv,dec,exp);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: nonblocking_assignment
	
	
	*** Parser Rule: procedural_continuous_assignments
		Access: public
		Return value(s): ProceduralContinuousAssign pca
		Init action:  pca=null; VariableAssignment vas=null; Lvalue lv=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "assign", "deassign", "force", "release" }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ "assign" }
				is matched.
				Match string literal "assign"
				Rule Reference: variable_assignment, assigned to 'vas'
				ACTION: pca = getTree().procContAssign(vas, true);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ "deassign" }
				is matched.
				Match string literal "deassign"
				Rule Reference: lvalue, assigned to 'lv'
				ACTION: pca = getTree().procContAssign(lv, true);
				
				Otherwise, Alternate(3) will be taken IF:
				The lookahead set: 
					{ "force" }
				is matched.
				Match string literal "force"
				Rule Reference: variable_assignment, assigned to 'vas'
				ACTION: pca = getTree().procContAssign(vas, false);
				
				Otherwise, Alternate(4) will be taken IF:
				The lookahead set: 
					{ "release" }
				is matched.
				Match string literal "release"
				Rule Reference: lvalue, assigned to 'lv'
				ACTION: pca = getTree().procContAssign(lv, false);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI }
	*** End Parser Rule: procedural_continuous_assignments
	
	
	*** Parser Rule: variable_assignment
		Access: public
		Return value(s): VariableAssignment va
		Init action:  va=null; Lvalue lv=null; Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LCURLY, IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LCURLY, IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: lvalue, assigned to 'lv'
			Match token ASSIGN
			Rule Reference: expression, assigned to 'exp'
			ACTION: va = getTree().variableAssignment(lv,exp);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, RPAREN }
	*** End Parser Rule: variable_assignment
	
	
	*** Parser Rule: par_block
		Access: public
		Return value(s): ParBlock pb
		Init action:  pb=null; BlockIdent bid=null; BlockItemDecl decl=null; Statement st=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "fork" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "fork" }
			is matched.
			Match string literal "fork"
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							POUND, LPAREN, LCURLY, COLON, "for", 
							"if", "case", "begin", "assign", "deassign", "force", 
							"release", "fork", "join", "repeat", "disable", AT, 
							TRIGGER, "wait", "casex", "casez", "forever", "while", 
							IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ COLON }
						is matched.
						Match token COLON
						Rule Reference: block_identifier, assigned to 'bid'
						Start ZERO-OR-MORE (...)+ block:
							Warning: This zero-or-more block is non-deterministic
							Start of an alternative block.
								The lookahead set for this block is:
									k==1: {
										LPAREN, "localparam", "parameter", "integer", "real", 
										"realtime", "time", "reg", "event"
									 }
									k==2: {
										LBRACK, "signed", "integer", "real", "realtime", 
										"time", STAR, IDENT, ESCAPED_IDENT
									 }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									k==1: {
										LPAREN, "localparam", "parameter", "integer", "real", 
										"realtime", "time", "reg", "event"
									 }
									k==2: {
										LBRACK, "signed", "integer", "real", "realtime", 
										"time", STAR, IDENT, ESCAPED_IDENT
									 }
								is matched.
								Rule Reference: block_item_declaration, assigned to 'decl'
								ACTION: pb = getTree().parBlock(pb,bid,decl);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								POUND, LPAREN, LCURLY, "for", "if", 
								"case", "begin", "assign", "deassign", "force", "release", 
								"fork", "join", "repeat", "disable", AT, TRIGGER, 
								"wait", "casex", "casez", "forever", "while", IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							POUND, LPAREN, LCURLY, "for", "if", 
							"case", "begin", "assign", "deassign", "force", "release", 
							"fork", "repeat", "disable", AT, TRIGGER, "wait", 
							"casex", "casez", "forever", "while", IDENT, ESCAPED_IDENT, 
							SYSTEM_TASK_NAME
						 }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ 
							POUND, LPAREN, LCURLY, "for", "if", 
							"case", "begin", "assign", "deassign", "force", "release", 
							"fork", "repeat", "disable", AT, TRIGGER, "wait", 
							"casex", "casez", "forever", "while", IDENT, ESCAPED_IDENT, 
							SYSTEM_TASK_NAME
						 }
					is matched.
					Rule Reference: statement, assigned to 'st'
					ACTION: pb = getTree().parBlock(pb,bid,st);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match string literal "join"
			ACTION: 
						pb = getTree().parBlock(pb,bid);
						getTree().popScope();
					
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", POUND, LPAREN, LCURLY, "defparam", 
				"localparam", "parameter", "specparam", "integer", "real", "realtime", 
				"time", "inout", "input", "output", "reg", "event", 
				"supply0", "supply1", "tri", "triand", "trior", "tri0", 
				"tri1", "uwire", "wire", "wand", "wor", "function", 
				"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
				"for", "if", "else", "case", "endcase", "default", 
				"begin", "end", "assign", "initial", "always", "deassign", 
				"force", "release", "fork", "join", "repeat", "disable", 
				AT, TRIGGER, "or", "wait", "casex", "casez", 
				"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: par_block
	
	
	*** Parser Rule: block_identifier
		Access: public
		Return value(s): BlockIdent rid
		Init action:  rid=null; Ident id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'id'
			ACTION: 	rid = getTree().blockIdentifier(id);
						getTree().addSymbol(rid);
					
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				POUND, LPAREN, LCURLY, "localparam", "parameter", 
				"integer", "real", "realtime", "time", "reg", "event", 
				"for", "if", "case", "begin", "end", "assign", 
				"deassign", "force", "release", "fork", "join", "repeat", 
				"disable", AT, TRIGGER, "wait", "casex", "casez", 
				"forever", "while", IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME
			 }
	*** End Parser Rule: block_identifier
	
	
	*** Parser Rule: seq_block
		Access: public
		Return value(s): SeqBlock sb
		Init action:  sb=null; BlockIdent bid=null; BlockItemDecl decl=null; Statement st=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "begin" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "begin" }
			is matched.
			Match string literal "begin"
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							POUND, LPAREN, LCURLY, COLON, "for", 
							"if", "case", "begin", "end", "assign", "deassign", 
							"force", "release", "fork", "repeat", "disable", AT, 
							TRIGGER, "wait", "casex", "casez", "forever", "while", 
							IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ COLON }
						is matched.
						Match token COLON
						Rule Reference: block_identifier, assigned to 'bid'
						Start ZERO-OR-MORE (...)+ block:
							Warning: This zero-or-more block is non-deterministic
							Start of an alternative block.
								The lookahead set for this block is:
									k==1: {
										LPAREN, "localparam", "parameter", "integer", "real", 
										"realtime", "time", "reg", "event"
									 }
									k==2: {
										LBRACK, "signed", "integer", "real", "realtime", 
										"time", STAR, IDENT, ESCAPED_IDENT
									 }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									k==1: {
										LPAREN, "localparam", "parameter", "integer", "real", 
										"realtime", "time", "reg", "event"
									 }
									k==2: {
										LBRACK, "signed", "integer", "real", "realtime", 
										"time", STAR, IDENT, ESCAPED_IDENT
									 }
								is matched.
								Rule Reference: block_item_declaration, assigned to 'decl'
								ACTION: sb = getTree().seqBlock(sb,bid,decl);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								POUND, LPAREN, LCURLY, "for", "if", 
								"case", "begin", "end", "assign", "deassign", "force", 
								"release", "fork", "repeat", "disable", AT, TRIGGER, 
								"wait", "casex", "casez", "forever", "while", IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							POUND, LPAREN, LCURLY, "for", "if", 
							"case", "begin", "assign", "deassign", "force", "release", 
							"fork", "repeat", "disable", AT, TRIGGER, "wait", 
							"casex", "casez", "forever", "while", IDENT, ESCAPED_IDENT, 
							SYSTEM_TASK_NAME
						 }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ 
							POUND, LPAREN, LCURLY, "for", "if", 
							"case", "begin", "assign", "deassign", "force", "release", 
							"fork", "repeat", "disable", AT, TRIGGER, "wait", 
							"casex", "casez", "forever", "while", IDENT, ESCAPED_IDENT, 
							SYSTEM_TASK_NAME
						 }
					is matched.
					Rule Reference: statement, assigned to 'st'
					ACTION: sb = getTree().seqBlock(sb,bid,st);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match string literal "end"
			ACTION: 
						sb = getTree().seqBlock(sb,bid);
						getTree().popScope();
					
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", POUND, LPAREN, LCURLY, "defparam", 
				"localparam", "parameter", "specparam", "integer", "real", "realtime", 
				"time", "inout", "input", "output", "reg", "event", 
				"supply0", "supply1", "tri", "triand", "trior", "tri0", 
				"tri1", "uwire", "wire", "wand", "wor", "function", 
				"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
				"for", "if", "else", "case", "endcase", "default", 
				"begin", "end", "assign", "initial", "always", "deassign", 
				"force", "release", "fork", "join", "repeat", "disable", 
				AT, TRIGGER, "or", "wait", "casex", "casez", 
				"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: seq_block
	
	
	*** Parser Rule: case_statement
		Access: public
		Return value(s): CaseStatement cs
		Init action:  cs=null; int tk=LA(1); Expression exp=null; CaseItem ci=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "case", "casex", "casez" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "case", "casex", "casez" }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ "case", "casex", "casez" }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "case" }
						is matched.
						Match string literal "case"
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "casex" }
						is matched.
						Match string literal "casex"
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ "casez" }
						is matched.
						Match string literal "casez"
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Match token LPAREN
			Rule Reference: expression, assigned to 'exp'
			Match token RPAREN
			ACTION: cs = getTree().caseStatement(tk, exp);
			Rule Reference: case_item, assigned to 'ci'
			ACTION: getTree().caseStatement(cs, ci);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							LPAREN, LCURLY, "default", NUMBER, STRING, 
							IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, 
							BNOT, BAND, RNAND, BOR, RNOR, BXOR, 
							RXNOR
						 }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ 
							LPAREN, LCURLY, "default", NUMBER, STRING, 
							IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, 
							BNOT, BAND, RNAND, BOR, RNOR, BXOR, 
							RXNOR
						 }
					is matched.
					Rule Reference: case_item, assigned to 'ci'
					ACTION: getTree().caseStatement(cs, ci);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match string literal "endcase"
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", POUND, LPAREN, LCURLY, "defparam", 
				"localparam", "parameter", "specparam", "integer", "real", "realtime", 
				"time", "inout", "input", "output", "reg", "event", 
				"supply0", "supply1", "tri", "triand", "trior", "tri0", 
				"tri1", "uwire", "wire", "wand", "wor", "function", 
				"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
				"for", "if", "else", "case", "endcase", "default", 
				"begin", "end", "assign", "initial", "always", "deassign", 
				"force", "release", "fork", "join", "repeat", "disable", 
				AT, TRIGGER, "or", "wait", "casex", "casez", 
				"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: case_statement
	
	
	*** Parser Rule: conditional_statement
		Access: public
		Return value(s): ConditionalStatement cs
		Init action:  cs=null; Expression exp=null; Statement s1=null, s2=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "if" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "if" }
			is matched.
			Match string literal "if"
			Match token LPAREN
			Rule Reference: expression, assigned to 'exp'
			Match token RPAREN
			Rule Reference: statement_or_null, assigned to 's1'
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {
							"endmodule", POUND, LPAREN, LCURLY, "defparam", 
							"localparam", "parameter", "specparam", "integer", "real", "realtime", 
							"time", "inout", "input", "output", "reg", "event", 
							"supply0", "supply1", "tri", "triand", "trior", "tri0", 
							"tri1", "uwire", "wire", "wand", "wor", "function", 
							"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
							"for", "if", "else", "case", "endcase", "default", 
							"begin", "end", "assign", "initial", "always", "deassign", 
							"force", "release", "fork", "join", "repeat", "disable", 
							AT, TRIGGER, "or", "wait", "casex", "casez", 
							"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
							SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
							MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
							BOR, RNOR, BXOR, RXNOR
						 }
						k==2: {
							EOF, SEMI, "endmodule", "module", "macromodule", 
							POUND, LPAREN, COMMA, DOT, LCURLY, LBRACK, 
							"defparam", "localparam", "signed", "parameter", "specparam", "integer", 
							"real", "realtime", "time", "inout", "input", "output", 
							"reg", "event", "vectored", "scalared", "supply0", "supply1", 
							"tri", "triand", "trior", "tri0", "tri1", "uwire", 
							"wire", "wand", "wor", ASSIGN, COLON, "function", 
							"automatic", "endfunction", "task", "endtask", "generate", "endgenerate", 
							"genvar", "for", QMARK, "if", "else", "case", 
							"endcase", "default", "begin", "end", "assign", "initial", 
							"always", LE, "deassign", "force", "release", "fork", 
							"join", "repeat", "disable", AT, STAR, TRIGGER, 
							"or", "wait", "casex", "casez", "forever", "while", 
							NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, "and", 
							"nand", "nor", "xor", "xnor", MINUS, PLUS, 
							LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
							BXOR, RXNOR, DIV, MOD, EQUAL, NOT_EQ, 
							NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, GT, 
							GE, SR, SL, SR3, SL3, STAR2
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {"else" }
							k==2: {
								SEMI, POUND, LPAREN, LCURLY, "for", 
								"if", "case", "begin", "assign", "deassign", "force", 
								"release", "fork", "repeat", "disable", AT, TRIGGER, 
								"wait", "casex", "casez", "forever", "while", IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME
							 }
						is matched.
						Match string literal "else"
						Rule Reference: statement_or_null, assigned to 's2'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {
								"endmodule", POUND, LPAREN, LCURLY, "defparam", 
								"localparam", "parameter", "specparam", "integer", "real", "realtime", 
								"time", "inout", "input", "output", "reg", "event", 
								"supply0", "supply1", "tri", "triand", "trior", "tri0", 
								"tri1", "uwire", "wire", "wand", "wor", "function", 
								"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
								"for", "if", "else", "case", "endcase", "default", 
								"begin", "end", "assign", "initial", "always", "deassign", 
								"force", "release", "fork", "join", "repeat", "disable", 
								AT, TRIGGER, "or", "wait", "casex", "casez", 
								"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
								SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
								MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
								BOR, RNOR, BXOR, RXNOR
							 }
							k==2: {
								EOF, SEMI, "endmodule", "module", "macromodule", 
								POUND, LPAREN, COMMA, DOT, LCURLY, LBRACK, 
								"defparam", "localparam", "signed", "parameter", "specparam", "integer", 
								"real", "realtime", "time", "inout", "input", "output", 
								"reg", "event", "vectored", "scalared", "supply0", "supply1", 
								"tri", "triand", "trior", "tri0", "tri1", "uwire", 
								"wire", "wand", "wor", ASSIGN, COLON, "function", 
								"automatic", "endfunction", "task", "endtask", "generate", "endgenerate", 
								"genvar", "for", QMARK, "if", "else", "case", 
								"endcase", "default", "begin", "end", "assign", "initial", 
								"always", LE, "deassign", "force", "release", "fork", 
								"join", "repeat", "disable", AT, STAR, TRIGGER, 
								"or", "wait", "casex", "casez", "forever", "while", 
								NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, "and", 
								"nand", "nor", "xor", "xnor", MINUS, PLUS, 
								LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
								BXOR, RXNOR, DIV, MOD, EQUAL, NOT_EQ, 
								NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, GT, 
								GE, SR, SL, SR3, SL3, STAR2
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: cs = getTree().conditionalStatement(exp, s1, s2);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", POUND, LPAREN, LCURLY, "defparam", 
				"localparam", "parameter", "specparam", "integer", "real", "realtime", 
				"time", "inout", "input", "output", "reg", "event", 
				"supply0", "supply1", "tri", "triand", "trior", "tri0", 
				"tri1", "uwire", "wire", "wand", "wor", "function", 
				"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
				"for", "if", "else", "case", "endcase", "default", 
				"begin", "end", "assign", "initial", "always", "deassign", 
				"force", "release", "fork", "join", "repeat", "disable", 
				AT, TRIGGER, "or", "wait", "casex", "casez", 
				"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: conditional_statement
	
	
	*** Parser Rule: disable_statement
		Access: public
		Return value(s): DisableStmt ds
		Init action:  ds=null; HierIdent hi=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "disable" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "disable" }
			is matched.
			Match string literal "disable"
			Rule Reference: hierarchical_identifier, assigned to 'hi'
			Match token SEMI
			ACTION: ds = getTree().disableStatement(hi);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", POUND, LPAREN, LCURLY, "defparam", 
				"localparam", "parameter", "specparam", "integer", "real", "realtime", 
				"time", "inout", "input", "output", "reg", "event", 
				"supply0", "supply1", "tri", "triand", "trior", "tri0", 
				"tri1", "uwire", "wire", "wand", "wor", "function", 
				"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
				"for", "if", "else", "case", "endcase", "default", 
				"begin", "end", "assign", "initial", "always", "deassign", 
				"force", "release", "fork", "join", "repeat", "disable", 
				AT, TRIGGER, "or", "wait", "casex", "casez", 
				"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: disable_statement
	
	
	*** Parser Rule: event_trigger
		Access: public
		Return value(s): EventTrigger et
		Init action:  et=null; HierEventIdent hei=null; Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ TRIGGER }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ TRIGGER }
			is matched.
			Match token TRIGGER
			Rule Reference: hierarchical_event_identifier, assigned to 'hei'
			ACTION: et = getTree().eventTrigger(hei);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LBRACK }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LBRACK }
					is matched.
					Match token LBRACK
					Rule Reference: expression, assigned to 'exp'
					Match token RBRACK
					ACTION: getTree().eventTrigger(et, exp);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match token SEMI
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", POUND, LPAREN, LCURLY, "defparam", 
				"localparam", "parameter", "specparam", "integer", "real", "realtime", 
				"time", "inout", "input", "output", "reg", "event", 
				"supply0", "supply1", "tri", "triand", "trior", "tri0", 
				"tri1", "uwire", "wire", "wand", "wor", "function", 
				"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
				"for", "if", "else", "case", "endcase", "default", 
				"begin", "end", "assign", "initial", "always", "deassign", 
				"force", "release", "fork", "join", "repeat", "disable", 
				AT, TRIGGER, "or", "wait", "casex", "casez", 
				"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: event_trigger
	
	
	*** Parser Rule: loop_statement
		Access: public
		Return value(s): LoopStatement lst
		Init action:  lst=null; Statement st=null; Expression exp=null; 
		VariableAssignment va1=null,va2=null; int tk=LA(1);
		Start of an alternative block.
			The lookahead set for this block is:
				{ "for", "repeat", "forever", "while" }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ "forever" }
				is matched.
				Match string literal "forever"
				Rule Reference: statement, assigned to 'st'
				ACTION: lst = getTree().loopStatement(st);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ "repeat" }
				is matched.
				Match string literal "repeat"
				Match token LPAREN
				Rule Reference: expression, assigned to 'exp'
				Match token RPAREN
				Rule Reference: statement, assigned to 'st'
				ACTION: lst = getTree().loopStatement(tk, exp, st);
				
				Otherwise, Alternate(3) will be taken IF:
				The lookahead set: 
					{ "while" }
				is matched.
				Match string literal "while"
				Match token LPAREN
				Rule Reference: expression, assigned to 'exp'
				Match token RPAREN
				Rule Reference: statement, assigned to 'st'
				ACTION: lst = getTree().loopStatement(tk, exp, st);
				
				Otherwise, Alternate(4) will be taken IF:
				The lookahead set: 
					{ "for" }
				is matched.
				Match string literal "for"
				Match token LPAREN
				Rule Reference: variable_assignment, assigned to 'va1'
				Match token SEMI
				Rule Reference: expression, assigned to 'exp'
				Match token SEMI
				Rule Reference: variable_assignment, assigned to 'va2'
				Match token RPAREN
				Rule Reference: statement, assigned to 'st'
				ACTION: lst = getTree().loopStatement(va1, exp, va2, st);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", POUND, LPAREN, LCURLY, "defparam", 
				"localparam", "parameter", "specparam", "integer", "real", "realtime", 
				"time", "inout", "input", "output", "reg", "event", 
				"supply0", "supply1", "tri", "triand", "trior", "tri0", 
				"tri1", "uwire", "wire", "wand", "wor", "function", 
				"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
				"for", "if", "else", "case", "endcase", "default", 
				"begin", "end", "assign", "initial", "always", "deassign", 
				"force", "release", "fork", "join", "repeat", "disable", 
				AT, TRIGGER, "or", "wait", "casex", "casez", 
				"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: loop_statement
	
	
	*** Parser Rule: procedural_timing_control_statement
		Access: public
		Return value(s): ProceduralTimingControlStatement pcs
		Init action:  pcs=null; ProceduralTimingControl pt=null; Statement st=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ POUND, AT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ POUND, AT }
			is matched.
			Rule Reference: procedural_timing_control, assigned to 'pt'
			Rule Reference: statement_or_null, assigned to 'st'
			ACTION: pcs = getTree().procTimingControlStmt(pt, st);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", POUND, LPAREN, LCURLY, "defparam", 
				"localparam", "parameter", "specparam", "integer", "real", "realtime", 
				"time", "inout", "input", "output", "reg", "event", 
				"supply0", "supply1", "tri", "triand", "trior", "tri0", 
				"tri1", "uwire", "wire", "wand", "wor", "function", 
				"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
				"for", "if", "else", "case", "endcase", "default", 
				"begin", "end", "assign", "initial", "always", "deassign", 
				"force", "release", "fork", "join", "repeat", "disable", 
				AT, TRIGGER, "or", "wait", "casex", "casez", 
				"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: procedural_timing_control_statement
	
	
	*** Parser Rule: system_task_enable
		Access: public
		Return value(s): SystemTaskEnable ste
		Init action:  ste=null; SystemTaskIdent sti=null; Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ SYSTEM_TASK_NAME }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ SYSTEM_TASK_NAME }
			is matched.
			Rule Reference: system_task_identifier, assigned to 'sti'
			ACTION: ste = getTree().systemTaskEnable(sti);
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ SEMI, LPAREN }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LPAREN }
						is matched.
						Match token LPAREN
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										LPAREN, RPAREN, COMMA, LCURLY, NUMBER, 
										STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
										LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
										BXOR, RXNOR
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ 
											LPAREN, LCURLY, NUMBER, STRING, IDENT, 
											ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
											BAND, RNAND, BOR, RNOR, BXOR, RXNOR
										 }
									is matched.
									Rule Reference: expression, assigned to 'exp'
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ RPAREN, COMMA }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						ACTION: getTree().systemTaskEnable(ste,exp); exp=null;
						Start ZERO-OR-MORE (...)+ block:
							Start of an alternative block.
								The lookahead set for this block is:
									{ COMMA }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ COMMA }
								is matched.
								Match token COMMA
								Start of alternative block.
									Start of an alternative block.
										The lookahead set for this block is:
											{ 
												LPAREN, RPAREN, COMMA, LCURLY, NUMBER, 
												STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
												LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
												BXOR, RXNOR
											 }
										This block has multiple alternatives:
											
											Alternate(1) will be taken IF:
											The lookahead set: 
												{ 
													LPAREN, LCURLY, NUMBER, STRING, IDENT, 
													ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
													BAND, RNAND, BOR, RNOR, BXOR, RXNOR
												 }
											is matched.
											Rule Reference: expression, assigned to 'exp'
											
											Otherwise, Alternate(2) will be taken IF:
											The lookahead set: 
												{ RPAREN, COMMA }
											is matched.
											
											OTHERWISE, a NoViableAlt exception will be thrown
											
										End of alternatives
									End of alternative block.
								ACTION: getTree().systemTaskEnable(ste,exp); exp=null;
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						Match token RPAREN
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ SEMI }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Match token SEMI
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", POUND, LPAREN, LCURLY, "defparam", 
				"localparam", "parameter", "specparam", "integer", "real", "realtime", 
				"time", "inout", "input", "output", "reg", "event", 
				"supply0", "supply1", "tri", "triand", "trior", "tri0", 
				"tri1", "uwire", "wire", "wand", "wor", "function", 
				"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
				"for", "if", "else", "case", "endcase", "default", 
				"begin", "end", "assign", "initial", "always", "deassign", 
				"force", "release", "fork", "join", "repeat", "disable", 
				AT, TRIGGER, "or", "wait", "casex", "casez", 
				"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: system_task_enable
	
	
	*** Parser Rule: task_enable
		Access: public
		Return value(s): TaskEnable te
		Init action:  te=null; HierTaskIdent hti=null; Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: hierarchical_task_identifier, assigned to 'hti'
			ACTION: te = getTree().taskEnable(hti);
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ SEMI, LPAREN }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LPAREN }
						is matched.
						Match token LPAREN
						Rule Reference: expression, assigned to 'exp'
						ACTION: getTree().taskEnable(te,exp);
						Start ZERO-OR-MORE (...)+ block:
							Start of an alternative block.
								The lookahead set for this block is:
									{ COMMA }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ COMMA }
								is matched.
								Match token COMMA
								Rule Reference: expression, assigned to 'exp'
								ACTION: getTree().taskEnable(te,exp);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						Match token RPAREN
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ SEMI }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Match token SEMI
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", POUND, LPAREN, LCURLY, "defparam", 
				"localparam", "parameter", "specparam", "integer", "real", "realtime", 
				"time", "inout", "input", "output", "reg", "event", 
				"supply0", "supply1", "tri", "triand", "trior", "tri0", 
				"tri1", "uwire", "wire", "wand", "wor", "function", 
				"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
				"for", "if", "else", "case", "endcase", "default", 
				"begin", "end", "assign", "initial", "always", "deassign", 
				"force", "release", "fork", "join", "repeat", "disable", 
				AT, TRIGGER, "or", "wait", "casex", "casez", 
				"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: task_enable
	
	
	*** Parser Rule: wait_statement
		Access: public
		Return value(s): WaitStatement ws
		Init action:  ws=null; Expression exp=null; Statement st=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ "wait" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "wait" }
			is matched.
			Match string literal "wait"
			Match token LPAREN
			Rule Reference: expression, assigned to 'exp'
			Match token RPAREN
			Rule Reference: statement_or_null, assigned to 'st'
			ACTION: ws = getTree().waitStatement(exp, st);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"endmodule", POUND, LPAREN, LCURLY, "defparam", 
				"localparam", "parameter", "specparam", "integer", "real", "realtime", 
				"time", "inout", "input", "output", "reg", "event", 
				"supply0", "supply1", "tri", "triand", "trior", "tri0", 
				"tri1", "uwire", "wire", "wand", "wor", "function", 
				"endfunction", "task", "endtask", "generate", "endgenerate", "genvar", 
				"for", "if", "else", "case", "endcase", "default", 
				"begin", "end", "assign", "initial", "always", "deassign", 
				"force", "release", "fork", "join", "repeat", "disable", 
				AT, TRIGGER, "or", "wait", "casex", "casez", 
				"forever", "while", NUMBER, STRING, IDENT, ESCAPED_IDENT, 
				SYSTEM_TASK_NAME, "and", "nand", "nor", "xor", "xnor", 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: wait_statement
	
	
	*** Parser Rule: delay_control
		Access: public
		Return value(s): DelayControl dc
		Init action:  dc=null; DelayValue dv=null; MinTypMaxExpression mtm=null;
		Start of an alternative block.
			The lookahead set for this block is:
				k==1: {POUND }
				k==2: {LPAREN, NUMBER, IDENT, ESCAPED_IDENT }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					k==1: {POUND }
					k==2: {NUMBER, IDENT, ESCAPED_IDENT }
				is matched.
				Match token POUND
				Rule Reference: delay_value, assigned to 'dv'
				ACTION: dc = getTree().delayControl(dv);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					k==1: {POUND }
					k==2: {LPAREN }
				is matched.
				Match token POUND
				Match token LPAREN
				Rule Reference: mintypmax_expression, assigned to 'mtm'
				Match token RPAREN
				ACTION: dc = getTree().delayControl(mtm);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, POUND, LPAREN, LCURLY, "for", 
				"if", "case", "begin", "assign", "deassign", "force", 
				"release", "fork", "repeat", "disable", AT, TRIGGER, 
				"wait", "casex", "casez", "forever", "while", NUMBER, 
				STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
				LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
				BXOR, RXNOR
			 }
	*** End Parser Rule: delay_control
	
	
	*** Parser Rule: event_control
		Access: public
		Return value(s): EventControl ec
		Init action:  ec=null; HierEventIdent hei=null; EventExpression ee=null;
		Start of an alternative block.
			The lookahead set for this block is:
				k==1: {AT }
				k==2: {LPAREN, STAR, IDENT, ESCAPED_IDENT }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					k==1: {AT }
					k==2: {IDENT, ESCAPED_IDENT }
				is matched.
				Match token AT
				Rule Reference: hierarchical_event_identifier, assigned to 'hei'
				ACTION: ec = getTree().eventControl(hei);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					k==1: {AT }
					k==2: {LPAREN }
				is matched.
				Match token AT
				Match token LPAREN
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								LPAREN, LCURLY, STAR, "posedge", "negedge", 
								NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, 
								PLUS, LNOT, BNOT, BAND, RNAND, BOR, 
								RNOR, BXOR, RXNOR
							 }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ STAR }
							is matched.
							Match token STAR
							ACTION: ec = getTree().eventControl(true);
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ 
									LPAREN, LCURLY, "posedge", "negedge", NUMBER, 
									STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
									LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
									BXOR, RXNOR
								 }
							is matched.
							Rule Reference: event_expression, assigned to 'ee'
							ACTION: ec = getTree().eventControl(ee);
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				Match token RPAREN
				
				Otherwise, Alternate(3) will be taken IF:
				The lookahead set: 
					k==1: {AT }
					k==2: {STAR }
				is matched.
				Match token AT
				Match token STAR
				ACTION: ec = getTree().eventControl(true);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, POUND, LPAREN, LCURLY, "for", 
				"if", "case", "begin", "assign", "deassign", "force", 
				"release", "fork", "repeat", "disable", AT, TRIGGER, 
				"wait", "casex", "casez", "forever", "while", NUMBER, 
				STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
				LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
				BXOR, RXNOR
			 }
	*** End Parser Rule: event_control
	
	
	*** Parser Rule: hierarchical_identifier
		Access: public
		Return value(s): HierIdent hid
		Init action:  hid = null; Object hi=null; Ident id=null;
		Error: This rule is non-deterministic
		Start of an alternative block.
			The lookahead set for this block is:
				k==1: {IDENT, ESCAPED_IDENT }
				k==2: {
					EOF, SEMI, POUND, LPAREN, RPAREN, 
					COMMA, DOT, LCURLY, RCURLY, LBRACK, RBRACK, 
					ASSIGN, COLON, "for", QMARK, "if", "case", 
					"begin", "assign", LE, "deassign", "force", "release", 
					"fork", "repeat", "disable", AT, STAR, TRIGGER, 
					"or", "wait", "casex", "casez", "forever", "while", 
					PLUS_COLON, MINUS_COLON, NUMBER, STRING, IDENT, ESCAPED_IDENT, 
					SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, BAND, 
					RNAND, BOR, RNOR, BXOR, RXNOR, DIV, 
					MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, 
					LOR, LT_, GT, GE, SR, SL, 
					SR3, SL3, STAR2
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					k==1: {IDENT, ESCAPED_IDENT }
					k==2: {DOT, LBRACK }
				is matched, AND the syntactic predicate:
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ IDENT, ESCAPED_IDENT }
							This block has a single alternative
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ IDENT, ESCAPED_IDENT }
							is matched.
							Rule Reference: identifier
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ DOT, LBRACK }
									This block has multiple alternatives:
										
										Alternate(1) will be taken IF:
										The lookahead set: 
											{ LBRACK }
										is matched.
										Match token LBRACK
										Rule Reference: constant_expression
										Match token RBRACK
										
										Otherwise, Alternate(2) will be taken IF:
										The lookahead set: 
											{ DOT }
										is matched.
										
										OTHERWISE, a NoViableAlt exception will be thrown
										
									End of alternatives
								End of alternative block.
							Match token DOT
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternative block.
				is matched.
				Rule Reference: hierarchical_identifier2, assigned to 'hi'
				ACTION: hid = getTree().hierarchicalIdentifier(hi);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					k==1: {IDENT, ESCAPED_IDENT }
					k==2: {
						EOF, SEMI, POUND, LPAREN, RPAREN, 
						COMMA, LCURLY, RCURLY, LBRACK, RBRACK, ASSIGN, 
						COLON, "for", QMARK, "if", "case", "begin", 
						"assign", LE, "deassign", "force", "release", "fork", 
						"repeat", "disable", AT, STAR, TRIGGER, "or", 
						"wait", "casex", "casez", "forever", "while", PLUS_COLON, 
						MINUS_COLON, NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, 
						MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
						BOR, RNOR, BXOR, RXNOR, DIV, MOD, 
						EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, 
						LT_, GT, GE, SR, SL, SR3, 
						SL3, STAR2
					 }
				is matched.
				Rule Reference: identifier, assigned to 'id'
				ACTION: hid = getTree().hierarchicalIdentifier(id);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, POUND, LPAREN, RPAREN, 
				COMMA, LCURLY, RCURLY, LBRACK, RBRACK, ASSIGN, 
				COLON, "for", QMARK, "if", "case", "begin", 
				"assign", LE, "deassign", "force", "release", "fork", 
				"repeat", "disable", AT, STAR, TRIGGER, "or", 
				"wait", "casex", "casez", "forever", "while", PLUS_COLON, 
				MINUS_COLON, NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR, DIV, MOD, 
				EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, 
				LT_, GT, GE, SR, SL, SR3, 
				SL3, STAR2
			 }
	*** End Parser Rule: hierarchical_identifier
	
	
	*** Parser Rule: hierarchical_event_identifier
		Access: public
		Return value(s): HierEventIdent rid
		Init action:  rid=null; HierIdent id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: hierarchical_identifier, assigned to 'id'
			ACTION: rid = getTree().hierarchicalEventIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, POUND, LPAREN, LCURLY, LBRACK, 
				"for", "if", "case", "begin", "assign", "deassign", 
				"force", "release", "fork", "repeat", "disable", AT, 
				TRIGGER, "wait", "casex", "casez", "forever", "while", 
				NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, 
				PLUS, LNOT, BNOT, BAND, RNAND, BOR, 
				RNOR, BXOR, RXNOR
			 }
	*** End Parser Rule: hierarchical_event_identifier
	
	
	*** Parser Rule: event_expression
		Access: public
		Return value(s): EventExpression ee
		Init action:  ee=null; Object e1=null, e2=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, "posedge", "negedge", NUMBER, 
					STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
					LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
					BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, "posedge", "negedge", NUMBER, 
					STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
					LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
					BXOR, RXNOR
				 }
			is matched.
			Rule Reference: event_expression_1, assigned to 'e1'
			Rule Reference: event_expression_2, assigned to 'e2'
			ACTION: ee = getTree().eventExpression(e1,e2);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN, COMMA, "or" }
	*** End Parser Rule: event_expression
	
	
	*** Parser Rule: event_expression_1
		Access: public
		Return value(s): Object e1
		Init action:  e1=null; Expression exp=null; int tk=LA(1);
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, "posedge", "negedge", NUMBER, 
					STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
					LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
					BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, "posedge", "negedge", NUMBER, 
					STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
					LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
					BXOR, RXNOR
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							LPAREN, LCURLY, "posedge", "negedge", NUMBER, 
							STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
							LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
							BXOR, RXNOR
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR
							 }
						is matched.
						Rule Reference: expression, assigned to 'exp'
						ACTION: tk=-1;
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "posedge" }
						is matched.
						Match string literal "posedge"
						Rule Reference: expression, assigned to 'exp'
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ "negedge" }
						is matched.
						Match string literal "negedge"
						Rule Reference: expression, assigned to 'exp'
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: e1 = getTree().event_expression_1(tk, exp);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN, COMMA, "or" }
	*** End Parser Rule: event_expression_1
	
	
	*** Parser Rule: event_expression_2
		Access: public
		Return value(s): Object e2
		Init action:  e2=null; EventExpression ee=null; Object ee2=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ RPAREN, COMMA, "or" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ RPAREN, COMMA, "or" }
			is matched.
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {RPAREN, COMMA, "or" }
						k==2: {
							SEMI, POUND, LPAREN, LCURLY, "for", 
							"if", "case", "begin", "assign", "deassign", "force", 
							"release", "fork", "repeat", "disable", AT, TRIGGER, 
							"posedge", "negedge", "wait", "casex", "casez", "forever", 
							"while", NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, 
							MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
							BOR, RNOR, BXOR, RXNOR
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {"or" }
							k==2: {
								LPAREN, LCURLY, "posedge", "negedge", NUMBER, 
								STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
								LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
								BXOR, RXNOR
							 }
						is matched.
						Match string literal "or"
						Rule Reference: event_expression, assigned to 'ee'
						Rule Reference: event_expression_2, assigned to 'ee2'
						ACTION: e2 = getTree().event_expression_2(true, ee, ee2);
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {COMMA }
							k==2: {
								LPAREN, LCURLY, "posedge", "negedge", NUMBER, 
								STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
								LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
								BXOR, RXNOR
							 }
						is matched.
						Match token COMMA
						Rule Reference: event_expression, assigned to 'ee'
						Rule Reference: event_expression_2, assigned to 'ee2'
						ACTION: e2 = getTree().event_expression_2(false, ee, ee2);
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							k==1: {RPAREN, COMMA, "or" }
							k==2: {
								SEMI, POUND, LPAREN, LCURLY, "for", 
								"if", "case", "begin", "assign", "deassign", "force", 
								"release", "fork", "repeat", "disable", AT, TRIGGER, 
								"posedge", "negedge", "wait", "casex", "casez", "forever", 
								"while", NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, 
								MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
								BOR, RNOR, BXOR, RXNOR
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN, COMMA, "or" }
	*** End Parser Rule: event_expression_2
	
	
	*** Parser Rule: procedural_timing_control
		Access: public
		Return value(s): ProceduralTimingControl ptc
		Init action:  ptc=null; DelayControl dc=null; EventControl ec=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ POUND, AT }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ POUND }
				is matched.
				Rule Reference: delay_control, assigned to 'dc'
				ACTION: ptc = getTree().proceduralTimingControl(dc);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ AT }
				is matched.
				Rule Reference: event_control, assigned to 'ec'
				ACTION: ptc = getTree().proceduralTimingControl(ec);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				SEMI, POUND, LPAREN, LCURLY, "for", 
				"if", "case", "begin", "assign", "deassign", "force", 
				"release", "fork", "repeat", "disable", AT, TRIGGER, 
				"wait", "casex", "casez", "forever", "while", IDENT, 
				ESCAPED_IDENT, SYSTEM_TASK_NAME
			 }
	*** End Parser Rule: procedural_timing_control
	
	
	*** Parser Rule: case_item
		Access: public
		Return value(s): CaseItem ci
		Init action:  ci=null; Expression exp=null; Statement stmt=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, "default", NUMBER, STRING, 
					IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, 
					BNOT, BAND, RNAND, BOR, RNOR, BXOR, 
					RXNOR
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ 
						LPAREN, LCURLY, NUMBER, STRING, IDENT, 
						ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
						BAND, RNAND, BOR, RNOR, BXOR, RXNOR
					 }
				is matched.
				Rule Reference: expression, assigned to 'exp'
				ACTION: ci = getTree().caseItem(exp);
				Start ZERO-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ COMMA }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ COMMA }
						is matched.
						Match token COMMA
						Rule Reference: expression, assigned to 'exp'
						ACTION: getTree().caseItem(ci, exp);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ZERO-OR-MORE block.
				Match token COLON
				Rule Reference: statement_or_null, assigned to 'stmt'
				ACTION: getTree().caseItem(ci, stmt);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ "default" }
				is matched.
				Match string literal "default"
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								SEMI, POUND, LPAREN, LCURLY, COLON, 
								"for", "if", "case", "begin", "assign", "deassign", 
								"force", "release", "fork", "repeat", "disable", AT, 
								TRIGGER, "wait", "casex", "casez", "forever", "while", 
								IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME
							 }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ COLON }
							is matched.
							Match token COLON
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ 
									SEMI, POUND, LPAREN, LCURLY, "for", 
									"if", "case", "begin", "assign", "deassign", "force", 
									"release", "fork", "repeat", "disable", AT, TRIGGER, 
									"wait", "casex", "casez", "forever", "while", IDENT, 
									ESCAPED_IDENT, SYSTEM_TASK_NAME
								 }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				Rule Reference: statement_or_null, assigned to 'stmt'
				ACTION: ci = getTree().caseItem(stmt);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				LPAREN, LCURLY, "endcase", "default", NUMBER, 
				STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, 
				LNOT, BNOT, BAND, RNAND, BOR, RNOR, 
				BXOR, RXNOR
			 }
	*** End Parser Rule: case_item
	
	
	*** Parser Rule: system_task_identifier
		Access: public
		Return value(s): SystemTaskIdent rid
		Init action:  rid=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ SYSTEM_TASK_NAME }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ SYSTEM_TASK_NAME }
			is matched.
			Match token SYSTEM_TASK_NAME, label=tk
			ACTION: rid = getTree().systemTaskIdentifier(tk);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, LPAREN }
	*** End Parser Rule: system_task_identifier
	
	
	*** Parser Rule: hierarchical_task_identifier
		Access: public
		Return value(s): HierTaskIdent rid
		Init action:  rid=null; HierIdent id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: hierarchical_identifier, assigned to 'id'
			ACTION: rid = getTree().hierarchicalTaskIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, LPAREN }
	*** End Parser Rule: hierarchical_task_identifier
	
	
	*** Parser Rule: concatenation
		Access: public
		Return value(s): Concatenation cc
		Init action:  cc=null; Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LCURLY }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LCURLY }
			is matched.
			Match token LCURLY
			Rule Reference: expression, assigned to 'exp'
			ACTION: cc=getTree().concatenation(null, exp);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: expression, assigned to 'exp'
					ACTION: getTree().concatenation(cc, exp);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match token RCURLY
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, RPAREN, COMMA, LCURLY, 
				RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
				"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
				BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
				NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
				GT, GE, SR, SL, SR3, SL3, 
				STAR2
			 }
	*** End Parser Rule: concatenation
	
	
	*** Parser Rule: multiple_concatenation
		Access: public
		Return value(s): MultConcatenation mc
		Init action:  mc=null; ConstExpression ce=null; Concatenation cc=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LCURLY }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LCURLY }
			is matched.
			Match token LCURLY
			Rule Reference: constant_expression, assigned to 'ce'
			Rule Reference: concatenation, assigned to 'cc'
			Match token RCURLY
			ACTION: mc = getTree().multipleConcatenation(ce, cc);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, RPAREN, COMMA, LCURLY, 
				RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
				"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
				BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
				NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
				GT, GE, SR, SL, SR3, SL3, 
				STAR2
			 }
	*** End Parser Rule: multiple_concatenation
	
	
	*** Parser Rule: function_call
		Access: public
		Return value(s): FunctionCall fc
		Init action:  fc=null; HierFunctionIdent hfi=null; Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: hierarchical_function_identifier, assigned to 'hfi'
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {LPAREN }
						k==2: {STAR }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						k==1: {LPAREN }
						k==2: {STAR }
					is matched.
					Rule Reference: attribute_instance
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match token LPAREN
			Rule Reference: expression, assigned to 'exp'
			ACTION: fc = getTree().functionCall(hfi, exp);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: expression, assigned to 'exp'
					ACTION: getTree().functionCall(fc, exp);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match token RPAREN
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, RPAREN, COMMA, LCURLY, 
				RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
				"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
				BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
				NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
				GT, GE, SR, SL, SR3, SL3, 
				STAR2
			 }
	*** End Parser Rule: function_call
	
	
	*** Parser Rule: hierarchical_function_identifier
		Access: public
		Return value(s): HierFunctionIdent rid
		Init action:  rid=null; HierIdent id=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: hierarchical_identifier, assigned to 'id'
			ACTION: rid = getTree().hierarchicalFunctionIdentifier(id);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {LPAREN }
	*** End Parser Rule: hierarchical_function_identifier
	
	
	*** Parser Rule: system_function_call
		Access: public
		Return value(s): SystemFunctionCall sfc
		Init action:  sfc=null; SystemFunctionIdent sfi=null; Expression exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ SYSTEM_TASK_NAME }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ SYSTEM_TASK_NAME }
			is matched.
			Rule Reference: system_function_identifier, assigned to 'sfi'
			ACTION: sfc = getTree().systemFunctionCall(sfi);
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							EOF, SEMI, LPAREN, RPAREN, COMMA, 
							LCURLY, RCURLY, RBRACK, COLON, QMARK, LE, 
							STAR, "or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, 
							BAND, BOR, BXOR, RXNOR, DIV, MOD, 
							EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, 
							LT_, GT, GE, SR, SL, SR3, 
							SL3, STAR2
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LPAREN }
						is matched.
						Match token LPAREN
						Rule Reference: expression, assigned to 'exp'
						ACTION: getTree().systemFunctionCall(sfc, exp);
						Start ZERO-OR-MORE (...)+ block:
							Start of an alternative block.
								The lookahead set for this block is:
									{ COMMA }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ COMMA }
								is matched.
								Match token COMMA
								Rule Reference: expression, assigned to 'exp'
								ACTION: getTree().systemFunctionCall(sfc, exp);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						Match token RPAREN
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								EOF, SEMI, RPAREN, COMMA, LCURLY, 
								RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
								"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
								BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
								NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
								GT, GE, SR, SL, SR3, SL3, 
								STAR2
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, RPAREN, COMMA, LCURLY, 
				RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
				"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
				BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
				NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
				GT, GE, SR, SL, SR3, SL3, 
				STAR2
			 }
	*** End Parser Rule: system_function_call
	
	
	*** Parser Rule: system_function_identifier
		Access: public
		Return value(s): SystemFunctionIdent rid
		Init action:  rid=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ SYSTEM_TASK_NAME }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ SYSTEM_TASK_NAME }
			is matched.
			Match token SYSTEM_TASK_NAME, label=tk
			ACTION: rid = getTree().systemFunctionIdentifier(tk);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, LPAREN, RPAREN, COMMA, 
				LCURLY, RCURLY, RBRACK, COLON, QMARK, LE, 
				STAR, "or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, 
				BAND, BOR, BXOR, RXNOR, DIV, MOD, 
				EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, 
				LT_, GT, GE, SR, SL, SR3, 
				SL3, STAR2
			 }
	*** End Parser Rule: system_function_identifier
	
	
	*** Parser Rule: base_expression
		Access: public
		Return value(s): Expression exp
		Init action:  exp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Rule Reference: expression, assigned to 'exp'
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {PLUS_COLON, MINUS_COLON }
	*** End Parser Rule: base_expression
	
	
	*** Parser Rule: constant_base_expression
		Access: public
		Return value(s): ConstExpression cexp
		Init action:  cexp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Rule Reference: constant_expression, assigned to 'cexp'
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {EOF }
	*** End Parser Rule: constant_base_expression
	
	
	*** Parser Rule: expression_1
		Access: public
		Return value(s): Object expr
		Init action: 	expr=null; Object uop=null, prim=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							LPAREN, LCURLY, NUMBER, STRING, IDENT, 
							ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
							BAND, RNAND, BOR, RNOR, BXOR, RXNOR
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME
							 }
						is matched.
						Rule Reference: primary, assigned to 'prim'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								MINUS, PLUS, LNOT, BNOT, BAND, 
								RNAND, BOR, RNOR, BXOR, RXNOR
							 }
						is matched.
						Rule Reference: unary_operator, assigned to 'uop'
						Start ZERO-OR-MORE (...)+ block:
							Warning: This zero-or-more block is non-deterministic
							Start of an alternative block.
								The lookahead set for this block is:
									k==1: {LPAREN }
									k==2: {STAR }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									k==1: {LPAREN }
									k==2: {STAR }
								is matched.
								Rule Reference: attribute_instance
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						Rule Reference: primary, assigned to 'prim'
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: expr = getTree().expression_1(uop, prim);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, RPAREN, COMMA, LCURLY, 
				RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
				"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
				BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
				NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
				GT, GE, SR, SL, SR3, SL3, 
				STAR2
			 }
	*** End Parser Rule: expression_1
	
	
	*** Parser Rule: expression_2
		Access: public
		Return value(s): Object expr
		Init action:  expr=null; Object e1=null, e2=null, e3=null; boolean isTernary=false;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					EOF, SEMI, RPAREN, COMMA, LCURLY, 
					RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
					"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
					BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
					NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
					GT, GE, SR, SL, SR3, SL3, 
					STAR2
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					EOF, SEMI, RPAREN, COMMA, LCURLY, 
					RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
					"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
					BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
					NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
					GT, GE, SR, SL, SR3, SL3, 
					STAR2
				 }
			is matched.
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {
							EOF, SEMI, RPAREN, COMMA, LCURLY, 
							RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
							"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
							BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
							NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
							GT, GE, SR, SL, SR3, SL3, 
							STAR2
						 }
						k==2: {
							EOF, SEMI, "endmodule", POUND, LPAREN, 
							RPAREN, COMMA, DOT, LCURLY, RCURLY, LBRACK, 
							RBRACK, "defparam", "localparam", "parameter", "specparam", "integer", 
							"real", "realtime", "time", "inout", "input", "output", 
							"reg", "event", "supply0", "supply1", "tri", "triand", 
							"trior", "tri0", "tri1", "uwire", "wire", "wand", 
							"wor", ASSIGN, COLON, "function", "endfunction", "task", 
							"endtask", "generate", "endgenerate", "genvar", "for", QMARK, 
							"if", "else", "case", "endcase", "default", "begin", 
							"end", "assign", "initial", "always", LE, "deassign", 
							"force", "release", "fork", "join", "repeat", "disable", 
							AT, STAR, TRIGGER, "posedge", "negedge", "or", 
							"wait", "casex", "casez", "forever", "while", PLUS_COLON, 
							MINUS_COLON, NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, 
							"and", "nand", "nor", "xor", "xnor", MINUS, 
							PLUS, LNOT, BNOT, BAND, RNAND, BOR, 
							RNOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
							NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
							GT, GE, SR, SL, SR3, SL3, 
							STAR2
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {
								LE, STAR, MINUS, PLUS, BAND, 
								BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
								NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
								GT, GE, SR, SL, SR3, SL3, 
								STAR2
							 }
							k==2: {
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR
							 }
						is matched.
						Rule Reference: binary_operator, assigned to 'e1'
						Start ZERO-OR-MORE (...)+ block:
							Warning: This zero-or-more block is non-deterministic
							Start of an alternative block.
								The lookahead set for this block is:
									k==1: {LPAREN }
									k==2: {STAR }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									k==1: {LPAREN }
									k==2: {STAR }
								is matched.
								Rule Reference: attribute_instance
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						Rule Reference: expression, assigned to 'e2'
						Rule Reference: expression_2, assigned to 'e3'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {QMARK }
							k==2: {
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR
							 }
						is matched.
						Match token QMARK
						Start ZERO-OR-MORE (...)+ block:
							Warning: This zero-or-more block is non-deterministic
							Start of an alternative block.
								The lookahead set for this block is:
									k==1: {LPAREN }
									k==2: {STAR }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									k==1: {LPAREN }
									k==2: {STAR }
								is matched.
								Rule Reference: attribute_instance
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						Rule Reference: expression, assigned to 'e1'
						Match token COLON
						Rule Reference: expression, assigned to 'e2'
						Rule Reference: expression_2, assigned to 'e3'
						ACTION: isTernary=true;
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							k==1: {
								EOF, SEMI, RPAREN, COMMA, LCURLY, 
								RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
								"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
								BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
								NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
								GT, GE, SR, SL, SR3, SL3, 
								STAR2
							 }
							k==2: {
								EOF, SEMI, "endmodule", POUND, LPAREN, 
								RPAREN, COMMA, DOT, LCURLY, RCURLY, LBRACK, 
								RBRACK, "defparam", "localparam", "parameter", "specparam", "integer", 
								"real", "realtime", "time", "inout", "input", "output", 
								"reg", "event", "supply0", "supply1", "tri", "triand", 
								"trior", "tri0", "tri1", "uwire", "wire", "wand", 
								"wor", ASSIGN, COLON, "function", "endfunction", "task", 
								"endtask", "generate", "endgenerate", "genvar", "for", QMARK, 
								"if", "else", "case", "endcase", "default", "begin", 
								"end", "assign", "initial", "always", LE, "deassign", 
								"force", "release", "fork", "join", "repeat", "disable", 
								AT, STAR, TRIGGER, "posedge", "negedge", "or", 
								"wait", "casex", "casez", "forever", "while", PLUS_COLON, 
								MINUS_COLON, NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, 
								"and", "nand", "nor", "xor", "xnor", MINUS, 
								PLUS, LNOT, BNOT, BAND, RNAND, BOR, 
								RNOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
								NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
								GT, GE, SR, SL, SR3, SL3, 
								STAR2
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: expr = getTree().expression_2(isTernary, e1, e2, e3);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, RPAREN, COMMA, LCURLY, 
				RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
				"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
				BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
				NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
				GT, GE, SR, SL, SR3, SL3, 
				STAR2
			 }
	*** End Parser Rule: expression_2
	
	
	*** Parser Rule: primary
		Access: public
		Return value(s): Primary prim
		Init action:  prim=null; Object o1=null; HierIdent id=null;
		Error: This rule is non-deterministic
		Start of an alternative block.
			The lookahead set for this block is:
				k==1: {
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME
				 }
				k==2: {
					EOF, SEMI, LPAREN, RPAREN, COMMA, 
					DOT, LCURLY, RCURLY, LBRACK, RBRACK, COLON, 
					QMARK, LE, STAR, "or", PLUS_COLON, MINUS_COLON, 
					NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, 
					PLUS, LNOT, BNOT, BAND, RNAND, BOR, 
					RNOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
					NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
					GT, GE, SR, SL, SR3, SL3, 
					STAR2
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ NUMBER }
				is matched.
				Rule Reference: number, assigned to 'o1'
				ACTION: prim = getTree().primary((Vnumber)o1);
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					k==1: {IDENT, ESCAPED_IDENT }
					k==2: {
						EOF, SEMI, RPAREN, COMMA, DOT, 
						LCURLY, RCURLY, LBRACK, RBRACK, COLON, QMARK, 
						LE, STAR, "or", PLUS_COLON, MINUS_COLON, MINUS, 
						PLUS, BAND, BOR, BXOR, RXNOR, DIV, 
						MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, 
						LOR, LT_, GT, GE, SR, SL, 
						SR3, SL3, STAR2
					 }
				is matched.
				Rule Reference: hierarchical_identifier, assigned to 'id'
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								EOF, SEMI, RPAREN, COMMA, LCURLY, 
								RCURLY, LBRACK, RBRACK, COLON, QMARK, LE, 
								STAR, "or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, 
								BAND, BOR, BXOR, RXNOR, DIV, MOD, 
								EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, 
								LT_, GT, GE, SR, SL, SR3, 
								SL3, STAR2
							 }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ LBRACK }
							is matched.
							Rule Reference: part_select, assigned to 'o1'
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ 
									EOF, SEMI, RPAREN, COMMA, LCURLY, 
									RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
									"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
									BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
									NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
									GT, GE, SR, SL, SR3, SL3, 
									STAR2
								 }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				ACTION: prim = getTree().primary(id, (PartSelect)o1);
				
				Otherwise, Alternate(3) will be taken IF:
				The lookahead set: 
					k==1: {IDENT, ESCAPED_IDENT }
					k==2: {LPAREN, DOT, LBRACK }
				is matched, AND the syntactic predicate:
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ IDENT, ESCAPED_IDENT }
							This block has a single alternative
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ IDENT, ESCAPED_IDENT }
							is matched.
							Rule Reference: function_call
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternative block.
				is matched.
				Rule Reference: function_call, assigned to 'o1'
				ACTION: prim = getTree().primary((FunctionCall)o1);
				
				Otherwise, Alternate(4) will be taken IF:
				The lookahead set: 
					k==1: {LCURLY }
					k==2: {
						LPAREN, LCURLY, NUMBER, STRING, IDENT, 
						ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
						BAND, RNAND, BOR, RNOR, BXOR, RXNOR
					 }
				is matched, AND the syntactic predicate:
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ LCURLY }
							This block has a single alternative
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ LCURLY }
							is matched.
							Rule Reference: multiple_concatenation
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternative block.
				is matched.
				Rule Reference: multiple_concatenation, assigned to 'o1'
				ACTION: prim = getTree().primary((MultConcatenation)o1);
				
				Otherwise, Alternate(5) will be taken IF:
				The lookahead set: 
					k==1: {LCURLY }
					k==2: {
						LPAREN, LCURLY, NUMBER, STRING, IDENT, 
						ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
						BAND, RNAND, BOR, RNOR, BXOR, RXNOR
					 }
				is matched.
				Rule Reference: concatenation, assigned to 'o1'
				ACTION: prim = getTree().primary((Concatenation)o1);
				
				Otherwise, Alternate(6) will be taken IF:
				The lookahead set: 
					{ SYSTEM_TASK_NAME }
				is matched.
				Rule Reference: system_function_call, assigned to 'o1'
				ACTION: prim = getTree().primary((SystemFunctionCall)o1);
				
				Otherwise, Alternate(7) will be taken IF:
				The lookahead set: 
					{ LPAREN }
				is matched.
				Match token LPAREN
				Rule Reference: mintypmax_expression, assigned to 'o1'
				Match token RPAREN
				ACTION: prim = getTree().primary((MinTypMaxExpression)o1);
				
				Otherwise, Alternate(8) will be taken IF:
				The lookahead set: 
					{ STRING }
				is matched.
				Rule Reference: string, assigned to 'o1'
				ACTION: prim = getTree().primary((Vstring)o1);
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, RPAREN, COMMA, LCURLY, 
				RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
				"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
				BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
				NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
				GT, GE, SR, SL, SR3, SL3, 
				STAR2
			 }
	*** End Parser Rule: primary
	
	
	*** Parser Rule: range_expression
		Access: public
		Return value(s): RangeExpression rexp
		Init action:  rexp=null; Expression lhs=null; ConstExpression rhs=null; int tk=LA(2);
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {
							LPAREN, LCURLY, NUMBER, STRING, IDENT, 
							ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
							BAND, RNAND, BOR, RNOR, BXOR, RXNOR
						 }
						k==2: {
							LPAREN, DOT, LCURLY, LBRACK, RBRACK, 
							COLON, QMARK, LE, STAR, PLUS_COLON, MINUS_COLON, 
							NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, 
							PLUS, LNOT, BNOT, BAND, RNAND, BOR, 
							RNOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
							NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
							GT, GE, SR, SL, SR3, SL3, 
							STAR2
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR
							 }
							k==2: {
								LPAREN, DOT, LCURLY, LBRACK, COLON, 
								QMARK, LE, STAR, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR, 
								DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, 
								LAND, LOR, LT_, GT, GE, SR, 
								SL, SR3, SL3, STAR2
							 }
						is matched, AND the syntactic predicate:
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ 
											LPAREN, LCURLY, NUMBER, STRING, IDENT, 
											ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
											BAND, RNAND, BOR, RNOR, BXOR, RXNOR
										 }
									This block has a single alternative
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ 
											LPAREN, LCURLY, NUMBER, STRING, IDENT, 
											ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
											BAND, RNAND, BOR, RNOR, BXOR, RXNOR
										 }
									is matched.
									Rule Reference: msb_constant_expression
									Match token COLON
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternative block.
						is matched.
						Rule Reference: msb_constant_expression, assigned to 'lhs'
						Match token COLON
						Rule Reference: lsb_constant_expression, assigned to 'rhs'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR
							 }
							k==2: {
								LPAREN, DOT, LCURLY, LBRACK, QMARK, 
								LE, STAR, PLUS_COLON, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR, 
								DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, 
								LAND, LOR, LT_, GT, GE, SR, 
								SL, SR3, SL3, STAR2
							 }
						is matched, AND the syntactic predicate:
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ 
											LPAREN, LCURLY, NUMBER, STRING, IDENT, 
											ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
											BAND, RNAND, BOR, RNOR, BXOR, RXNOR
										 }
									This block has a single alternative
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ 
											LPAREN, LCURLY, NUMBER, STRING, IDENT, 
											ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
											BAND, RNAND, BOR, RNOR, BXOR, RXNOR
										 }
									is matched.
									Rule Reference: base_expression
									Match token PLUS_COLON
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternative block.
						is matched.
						Rule Reference: base_expression, assigned to 'lhs'
						Match token PLUS_COLON
						Rule Reference: width_constant_expression, assigned to 'rhs'
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							k==1: {
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR
							 }
							k==2: {
								LPAREN, DOT, LCURLY, LBRACK, QMARK, 
								LE, STAR, MINUS_COLON, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR, 
								DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, 
								LAND, LOR, LT_, GT, GE, SR, 
								SL, SR3, SL3, STAR2
							 }
						is matched, AND the syntactic predicate:
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ 
											LPAREN, LCURLY, NUMBER, STRING, IDENT, 
											ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
											BAND, RNAND, BOR, RNOR, BXOR, RXNOR
										 }
									This block has a single alternative
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ 
											LPAREN, LCURLY, NUMBER, STRING, IDENT, 
											ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
											BAND, RNAND, BOR, RNOR, BXOR, RXNOR
										 }
									is matched.
									Rule Reference: base_expression
									Match token MINUS_COLON
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternative block.
						is matched.
						Rule Reference: base_expression, assigned to 'lhs'
						Match token MINUS_COLON
						Rule Reference: width_constant_expression, assigned to 'rhs'
						
						Otherwise, Alternate(4) will be taken IF:
						The lookahead set: 
							k==1: {
								LPAREN, LCURLY, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR
							 }
							k==2: {
								LPAREN, DOT, LCURLY, LBRACK, RBRACK, 
								QMARK, LE, STAR, NUMBER, STRING, IDENT, 
								ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
								BAND, RNAND, BOR, RNOR, BXOR, RXNOR, 
								DIV, MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, 
								LAND, LOR, LT_, GT, GE, SR, 
								SL, SR3, SL3, STAR2
							 }
						is matched.
						Rule Reference: expression, assigned to 'lhs'
						ACTION: tk=-1;
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: rexp = getTree().rangeExpression(lhs, tk, rhs);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RBRACK }
	*** End Parser Rule: range_expression
	
	
	*** Parser Rule: width_constant_expression
		Access: public
		Return value(s): ConstExpression cexp
		Init action:  cexp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					LPAREN, LCURLY, NUMBER, STRING, IDENT, 
					ESCAPED_IDENT, SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, 
					BAND, RNAND, BOR, RNOR, BXOR, RXNOR
				 }
			is matched.
			Rule Reference: constant_expression, assigned to 'cexp'
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RBRACK }
	*** End Parser Rule: width_constant_expression
	
	
	*** Parser Rule: part_select
		Access: public
		Return value(s): PartSelect ps
		Init action:  ps=null; RangeExpression rexp=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ LBRACK }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LBRACK }
			is matched.
			Start ONE-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LBRACK }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LBRACK }
					is matched.
					Match token LBRACK
					Rule Reference: range_expression, assigned to 'rexp'
					ACTION: ps = getTree().partSelect(ps, rexp);
					Match token RBRACK
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ONE-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, RPAREN, COMMA, LCURLY, 
				RCURLY, RBRACK, ASSIGN, COLON, QMARK, LE, 
				STAR, "or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, 
				BAND, BOR, BXOR, RXNOR, DIV, MOD, 
				EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, 
				LT_, GT, GE, SR, SL, SR3, 
				SL3, STAR2
			 }
	*** End Parser Rule: part_select
	
	
	*** Parser Rule: string
		Access: public
		Return value(s): Vstring v
		Init action:  v = null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ STRING }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ STRING }
			is matched.
			Match token STRING, label=tk
			ACTION: v = getTree().string(tk);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, RPAREN, COMMA, LCURLY, 
				RCURLY, RBRACK, COLON, QMARK, LE, STAR, 
				"or", PLUS_COLON, MINUS_COLON, MINUS, PLUS, BAND, 
				BOR, BXOR, RXNOR, DIV, MOD, EQUAL, 
				NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, LT_, 
				GT, GE, SR, SL, SR3, SL3, 
				STAR2
			 }
	*** End Parser Rule: string
	
	
	*** Parser Rule: lvalue2
		Access: public
		Return value(s): Object o1
		Init action:  o1=null; HierIdent hi=null; PartSelect ps=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: hierarchical_identifier, assigned to 'hi'
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							SEMI, COMMA, RCURLY, LBRACK, ASSIGN, 
							LE
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LBRACK }
						is matched.
						Rule Reference: part_select, assigned to 'ps'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ SEMI, COMMA, RCURLY, ASSIGN, LE }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: o1 = getTree().lvalue2(hi,ps);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {SEMI, COMMA, RCURLY, ASSIGN, LE }
	*** End Parser Rule: lvalue2
	
	
	*** Parser Rule: attr_spec
		Access: public
		Return value: none
		Init action:  ConstExpression unused=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: attr_name
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA, ASSIGN, STAR }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ ASSIGN }
						is matched.
						Match token ASSIGN
						Rule Reference: constant_expression, assigned to 'unused'
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ COMMA, STAR }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {COMMA, STAR }
	*** End Parser Rule: attr_spec
	
	
	*** Parser Rule: attr_name
		Access: public
		Return value: none
		Init action:  Ident unused=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'unused'
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {COMMA, ASSIGN, STAR }
	*** End Parser Rule: attr_name
	
	
	*** Parser Rule: hierarchical_identifier2
		Access: public
		Return value(s): Object hid
		Init action:  hid=null; Ident id=null; ConstExpression cex=null; HierIdent hid2=null;
		Start of an alternative block.
			The lookahead set for this block is:
				{ IDENT, ESCAPED_IDENT }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ IDENT, ESCAPED_IDENT }
			is matched.
			Rule Reference: identifier, assigned to 'id'
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ DOT, LBRACK }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ LBRACK }
						is matched.
						Match token LBRACK
						Rule Reference: constant_expression, assigned to 'cex'
						Match token RBRACK
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ DOT }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: hid = getTree().hierarchicalIdentifier2(id, cex);
			Match token DOT
			Start ONE-OR-MORE (...)+ block:
				Warning: This one-or-more block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {IDENT, ESCAPED_IDENT }
						k==2: {
							EOF, SEMI, POUND, LPAREN, RPAREN, 
							COMMA, DOT, LCURLY, RCURLY, LBRACK, RBRACK, 
							ASSIGN, COLON, "for", QMARK, "if", "case", 
							"begin", "assign", LE, "deassign", "force", "release", 
							"fork", "repeat", "disable", AT, STAR, TRIGGER, 
							"or", "wait", "casex", "casez", "forever", "while", 
							PLUS_COLON, MINUS_COLON, NUMBER, STRING, IDENT, ESCAPED_IDENT, 
							SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, BAND, 
							RNAND, BOR, RNOR, BXOR, RXNOR, DIV, 
							MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, 
							LOR, LT_, GT, GE, SR, SL, 
							SR3, SL3, STAR2
						 }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						k==1: {IDENT, ESCAPED_IDENT }
						k==2: {
							EOF, SEMI, POUND, LPAREN, RPAREN, 
							COMMA, DOT, LCURLY, RCURLY, LBRACK, RBRACK, 
							ASSIGN, COLON, "for", QMARK, "if", "case", 
							"begin", "assign", LE, "deassign", "force", "release", 
							"fork", "repeat", "disable", AT, STAR, TRIGGER, 
							"or", "wait", "casex", "casez", "forever", "while", 
							PLUS_COLON, MINUS_COLON, NUMBER, STRING, IDENT, ESCAPED_IDENT, 
							SYSTEM_TASK_NAME, MINUS, PLUS, LNOT, BNOT, BAND, 
							RNAND, BOR, RNOR, BXOR, RXNOR, DIV, 
							MOD, EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, 
							LOR, LT_, GT, GE, SR, SL, 
							SR3, SL3, STAR2
						 }
					is matched.
					Rule Reference: hierarchical_identifier, assigned to 'hid2'
					ACTION: getTree().hierarchicalIdentifier2(hid, hid2);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ONE-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, SEMI, POUND, LPAREN, RPAREN, 
				COMMA, LCURLY, RCURLY, LBRACK, RBRACK, ASSIGN, 
				COLON, "for", QMARK, "if", "case", "begin", 
				"assign", LE, "deassign", "force", "release", "fork", 
				"repeat", "disable", AT, STAR, TRIGGER, "or", 
				"wait", "casex", "casez", "forever", "while", PLUS_COLON, 
				MINUS_COLON, NUMBER, STRING, IDENT, ESCAPED_IDENT, SYSTEM_TASK_NAME, 
				MINUS, PLUS, LNOT, BNOT, BAND, RNAND, 
				BOR, RNOR, BXOR, RXNOR, DIV, MOD, 
				EQUAL, NOT_EQ, NOT_EQ_CASE, EQ_CASE, LAND, LOR, 
				LT_, GT, GE, SR, SL, SR3, 
				SL3, STAR2
			 }
	*** End Parser Rule: hierarchical_identifier2

*** End of parser rules

*** End of parser
