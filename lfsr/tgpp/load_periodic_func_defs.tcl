
namespace eval periodic_func_defs {
    set version 0.1
	variable defs [dict create]
}

proc periodic_func_defs::lFilterEmpty {alist} {
    set out [list]
    foreach arg $alist {
        if {""!=$arg} { lappend out $arg }    
    }
    return $out
}

proc periodic_func_defs::string_occurrences {needleString haystackString} {

    set j [string first $needleString $haystackString 0]
    if {$j == -1} {return 0}

    set i 0
    while {$j != -1 } {
        set j [string first $needleString $haystackString [incr j]]
        incr i
    }

    return $i
}

proc periodic_func_defs::compute_taps_cost { taps } {
	set nO [string_occurrences "O" $taps] 
	set nXor [string_occurrences "^" $taps] 
	set cost [expr [string length $taps]*0x10000 + $nO*2 + $nXor]
	return $cost
}

# Periodic function definition reader
# Read a csv file and add all definitions to a dict.
# Csv file is expected to contain the following for each line:
# len,<the period in decimal>,[one or more function definition]
#
# Function definition consist of two comma separated field:
# - the boolean function
# - the initial value for the state, in binary
#
# The boolean function is defined using the syntax generated by the java class "Nlfsr"
proc periodic_func_defs::add_periodic_func_defs { file_name dict_name {max_func_per_period 1} } {
	upvar $dict_name nlfsrDb
	set f [open $file_name r]
	while {[gets $f line] > -1} { #for each line
		set items [split $line ,]
		set len [scan [lindex $items 1] %d]
		set tapsDefs [lFilterEmpty [lrange $items 2 end]]
		set nTaps [expr [llength $tapsDefs] / 2]
		set nFuncs 0
		set curCost 0x7FFFFFFF
		if {[dict exist $nlfsrDb $len]} {
			set nFuncs [dict size [dict get $nlfsrDb $len]]
			set curCost [compute_taps_cost [dict get $nlfsrDb $len 0 taps]]
			#if { $len == 121 } { puts "[dict get $nlfsrDb $len 0] -> $curCost" }
		}
		if { 1 == $max_func_per_period } {
			#keep only the cheapest function for each period
			set keep_cheapest 1
			set limit $nTaps
		} else {
			set keep_cheapest 0
			set limit [expr $max_func_per_period - $nFuncs]
		}
		for {set i 0} {$i<$limit} {incr i} {
			set taps [lindex $tapsDefs [expr 2*$i]]
			set init [lindex $tapsDefs [expr 2*$i+1]] 
			if {$keep_cheapest} {
				set newCost [compute_taps_cost $taps]
				if { $newCost < $curCost } {
					dict set nlfsrDb $len 0 taps $taps
					dict set nlfsrDb $len 0 init $init 
					set curCost $newCost
					#if { $len == 121 } { puts "$taps -> $curCost" }
				}
			} else {
				dict set nlfsrDb $len $i taps $taps
				dict set nlfsrDb $len $i init $init 
			}
		}
	}
	close $f
}

proc periodic_func_defs::convert_taps_from_nlfsrdb { taps } {
	set len [string length $taps]
	if { 0 != ($len % 2) } {
		#error "Invalid argument, need an even number of characters, got $len ($taps)"
	}
	set out [dict create]
	set nTaps [expr  $len / 2]
	for {set i 0} {$i<$nTaps} {incr i} {
		set in1 [expr ($i+1) % $nTaps]
		set func [list]
		set tap [string range $taps [expr 2*$in1] [expr 2*$in1+1]]
		#puts "\t'$tap'"
		switch $tap {
			" >" {lappend func $in1}
			" ~" {lappend func not $in1}
			" &" {lappend func and $in1 0}
			" |" {lappend func or $in1 0}
			" ^" {lappend func xor $in1 0}
			"!&" {lappend func nand $in1 0}
			"!|" {lappend func nor $in1 0}
			"!^" {lappend func xnor $in1 0}
			"OA" {lappend func and $in1 or 1 0}
			"OX" {lappend func xor $in1 or 1 0}
			"O2" {lappend func xor $in1 or 2 0}
		}
		dict set out $i $func
	}
	return $out
}

# Cache the translation from java output to our dict structure as this takes few seconds
# The cache file is created by a TGPP file although it could be easily done here.
# if that's desired, it is as simple as writing out $periodic_func_defs::defs to the file
# the file must assign the resulting dict to the variable name periodic_func_defs::defs
set cached_defs [file join [file dirname [info script]] periodic_func_defs.tcl]
if {[file exist $cached_defs]} {
	source $cached_defs
} else {
	set dbPath ..
	foreach width [list 4 5 6 7 8] {
		set fName [file join $dbPath NlfsrDb${width}.csv]
		periodic_func_defs::add_periodic_func_defs $fName periodic_func_defs::defs
	}
}

proc periodic_func_defs::test {} {
	dict for {len taps} $periodic_func_defs::defs {
		puts "$len: [dict size $taps] taps"
		puts $taps
		puts [periodic_func_defs::convert_taps_from_nlfsrdb [dict get [lindex $taps end] taps]]
	}
}

# To get a function with period 13, call like this: 
# set func_spec [periodic_func_defs::get_func_spec [dict create period 13]]
proc periodic_func_defs::get_func_spec { periodic_func_spec } {
	set period [dict get $periodic_func_spec period]
	#get the first function for the target period
	set def [dict get $periodic_func_defs::defs $period 0]
	dict set periodic_func_spec init [dict get $def init]
	set taps [periodic_func_defs::convert_taps_from_nlfsrdb [dict get $def taps]]
	dict set periodic_func_spec taps $taps
}

proc swap {a_name b_name} {
	upvar $a_name a
	upvar $b_name b
	set t $a
	set a $b
	set b $t
}

# generate verilog code to compute a boolean function
# the pos arguement is for the purpose of recursion, user must not set it.
# func_spec is exected to be a dict containing the following:
# input_name: name of the input signal
# func: a list where elements are either operator name or position of input bits
# example
# set func [list xor 0 1] --> in[0] ^ in[1]
# set func [list xor 0 and 1 2] --> in[0] ^ (in[1] & in[2])
proc gen_boolean_func { func_spec {pos_name ""} } {
	set input_name [dict get $func_spec input_name]
	set func [dict get $func_spec func]
	if {$pos_name == ""} {
		set pos 0
	} else { upvar $pos_name pos }
	#puts "__${func}__"
	#puts [llength $func]
	if ([expr [llength $func]==1]) {
		#single entry, assume it is an input position
		tgpp::wr $input_name\[[lindex $func 0]\]
		return [tgpp::getProcOutput]
	}
	set op [lindex $func $pos]
	incr pos
	set arg1 [lindex $func $pos]
	if {![string is digit $arg1]} { 
		set arg1 [gen_boolean_func $func_spec pos] 
	} else { incr pos; set arg1 $input_name\[$arg1\] }
	if {$op == "not"} {
		tgpp::wr ~$arg1
	} else {
		set arg2 [lindex $func $pos]
		if {![string is digit $arg2]} { 
			set arg2 [gen_boolean_func $func_spec pos] 
		} else { incr pos; set arg2 $input_name\[$arg2\] }
		tgpp::wr ($arg1
		#puts "_${op}_"
		switch $op {
			xor 	{ tgpp::wr ^  }
			xnor	{ tgpp::wr ^~ }
			and 	{ tgpp::wr &  }
			nand	{ tgpp::wr ~& }
			or	 	{ tgpp::wr |  }
			nor		{ tgpp::wr ~| }
		}
		tgpp::wr ${arg2})
	}
	return [tgpp::getProcOutput]
}

