package uk.co.nimp.app;

import uk.co.nimp.Lfsr;
import uk.co.nimp.Z2;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.util.*;

import static uk.co.nimp.app.MainHelpers.*;
/**
 * Created by seb on 6/22/14.
 */
public class LfsrTool {
    static String helpMessage(){
        String msg="LFSR tool help\n";
        msg+="command line: java -cp z2.jar uk.co.nimp.app.LfsrTool [arguments...]\n";
        msg+="Arguments:\n";
        msg+=argDescription(ARG_HELP,null,"Display this help and exit");
        msg+=argDescription(ARG_DISP_SEQ,null,"Display the sequence generated by LFSRs");
        msg+=argDescription(ARG_DISP_SEQ_STATES,null,"Display the sequence generated by LFSRs and the successive states");
        msg+=argDescription(ARG_ENDIANNESS,null,"Try various variation of endianness of the reference sequence");
        msg+=argDescription(ARG_LFSR_BINSTR,"binaryString","Load a reference LFSR from its binary string representation");
        msg+=argDescription(ARG_LFSR_POLY,"polynomial","Load a reference LFSR from its polynomial representation");
        msg+=argDescription(ARG_PROFILING,null,"Ask for user interaction before and after the processing.");
        msg+=argDescription(ARG_SEQ_BINFILE,"file, offset, length","Load a reference sequence from a binary file. Offset and length in bytes.");
        msg+=argDescription(ARG_SEQ_BINSTRFILE,"file","Load a reference sequence from a binary string file");
        msg+=argDescription(ARG_SEQ_BINSTR,"binaryString","Load a reference sequence from a binary string");
        msg+=argDescription(ARG_SEQ_HEXSTR,"hexByteString","Load a reference sequence from a hex byte string");
        //msg+=argDescription(ARG_TO_BINSTRFILE,"file","Write sequence(s) to binary string file(s)");

        msg+="\n";
        msg+="Behavior:\n";
        msg+="If a reference sequence is given, the minimum length LFSR which generates it is computed.\n";
        msg+="If a reference LFSR is given, its properties are computed (maximum length or not, sequence length....\n";
        msg+="If a reference LFSR is given and a reference sequence as well:\n";
        msg+=tab+"- The reference LFSR is compared with the one computed from the sequence.\n";
        msg+=tab+"- The reference sequence is search inside the sequence generated by the reference LFSR\n";
        msg+="\n"+credits;
        //msg+="\n0123456789abcdefghij0123456789abcdefghij0123456789abcdefghij0123456789abcdefghijtt";
        msg = limitLineLength(msg,78);
        return msg;
    }

    static void runDemo(String []args,String description,int index) {
        System.out.println("Run "+index+" "+description);
        try {
            main(args);
        } catch (Throwable e) {
            e.printStackTrace();
        }
        System.out.println("---------------------------------------------------");
    }
    public static void demo() throws IOException {
        int i=0;
        System.out.println("---------------------------------------------------");
        runDemo(new String[]{ARG_SEQ_BINSTR, "001101110"}, "Find the LFSR generating a sequence given as a binary string", i++);
        runDemo(new String[]{ARG_SEQ_BINSTR,"001010011100101110111",ARG_DISP_SEQ},"Find the LFSR generating a sequence given as a binary string and display generated sequence",i++);
        runDemo(new String[]{ARG_LFSR_POLY,"1 + x3 + x5",ARG_DISP_SEQ},"Display the properties of an LFSR given as a polynomial,\n"+tab+"display also the generated sequence",i++);
        runDemo(new String[]{ARG_LFSR_BINSTR,"100101"},"Display the properties of an LFSR given as a binary string",i++);
        Lfsr l= Lfsr.fromPolynomial("1+x3+x5");
        boolean[] seq = Z2.cloneRange(l.sequence(),0,10);
        System.out.println("Create a file containing the binary sequence "+Z2.toBinaryString(seq));
        File tmp = File.createTempFile("LFSR_demo", ".dat");
        Z2.toBinaryFile(tmp,seq);
        runDemo(new String[]{ARG_SEQ_BINFILE, tmp.getCanonicalPath(),"0","0"}, "Find the LFSR generating a sequence given in a binary file", i++);
        l= Lfsr.fromPolynomial("1+x+x7");
        seq = Z2.cloneRange(l.sequence(),0,24);
        System.out.println("Create a text file containing the binary sequence "+Z2.toBinaryString(seq));
        tmp = File.createTempFile("LFSR_demo", ".dat");
        Z2.toBinaryStringFile(tmp,seq);
        runDemo(new String[]{ARG_SEQ_BINSTRFILE, tmp.getCanonicalPath()}, "Find the LFSR generating a sequence given in a binary string file (a text file containing 0 and 1)", i++);
        runDemo(new String[]{ARG_SEQ_BINSTR,"100000011111110101010011"},"Display the properties of an LFSR computed from a sequence given as a binary string",i++);

        runDemo(new String[]{ARG_SEQ_BINSTR,"0001101110",ARG_LFSR_POLY,"1 + x3 + x5"},"Compare a sequence with an LFSR",i++);
        runDemo(new String[]{ARG_SEQ_BINSTR,"101110",ARG_LFSR_POLY,"1 + x3 + x5",ARG_DISP_SEQ},"Compare a short sequence with an LFSR and display sequences",i++);

        runDemo(new String[]{ARG_LFSR_POLY,"1+x+x5",ARG_DISP_SEQ_STATES},"Display the properties of an LFSR given as a polynomial,\n"+tab+"display also the generated sequence and associated the states",i++);
        runDemo(new String[]{ARG_LFSR_POLY,"1+x3+x12",ARG_DISP_SEQ},"Display the properties of an LFSR given as a polynomial,\n"+tab+"display also the generated sequence without the states",i++);

        runDemo(new String[]{ARG_SEQ_BINSTR,"10000011111110101010011000110111",ARG_ENDIANNESS},"Display the properties of an LFSR computed from a sequence given as a binary string,"+
                "\n"+tab+"display also the LFSR computed from variation of the endianness of this sequence",i++);

        runDemo(new String[]{ARG_SEQ_HEXSTR,"06 03 C1 98"},"Find the LFSR generating a sequence given in an hex string ",i++);

        //runDemo(new String[]{ARG_SEQ_HEXSTR,"60 C0 83 19"},"debug",i++);
        //runDemo(new String[]{ARG_LFSR_POLY,Z2.toPolynomial(Z2.pow(Z2.polynomialToBooleans("1+x+x3"),2)),ARG_DISP_SEQ_STATES},"debug",i++);
        //runDemo(new String[]{ARG_LFSR_POLY,Z2.toPolynomial(Z2.pow(Z2.polynomialToBooleans("1+x+x2+x3+x4"),6)),ARG_DISP_SEQ_STATES},"debug",i++);
        //runDemo(new String[]{ARG_LFSR_POLY,Z2.toPolynomial(Z2.pow(Z2.polynomialToBooleans("1+x+x2+x3+x4"),7)),ARG_DISP_SEQ_STATES},"debug",i++);
        //runDemo(new String[]{ARG_LFSR_POLY,Z2.toPolynomial(Z2.mul(Z2.pow(Z2.polynomialToBooleans("1+x+x3"),2),Z2.polynomialToBooleans("1+x"))),ARG_DISP_SEQ_STATES},"debug",i++);
        //runDemo(new String[]{ARG_LFSR_POLY,Z2.toPolynomial(Z2.mul(Z2.pow(Z2.polynomialToBooleans("1+x"),2),Z2.polynomialToBooleans("1+x+x3"))),ARG_DISP_SEQ_STATES},"debug",i++);

    }

    public static void main(String[] args) throws IOException {
        int len=-1;
        if(args.length==0) {
            System.out.println("No argument found, launch demo");
            try{
                demo();
            }catch(Exception e){
                e.printStackTrace();
            }
            System.out.println(helpMessage());
            System.exit(1);
        }
        System.out.println("Arguments:");
        for(int i = 0;i<args.length;i++){
            System.out.println(i+tab+args[i]);
        }
        boolean[] refSequence=null;
        boolean dispSeq=false;
        boolean dispSeqStates=false;
        boolean endianness=false;
        boolean profiling=false;
        boolean toBinStrFile=false;
        Lfsr refLfsr=null;
        for(int i=0;i<args.length;i++) {
            if (args[i].equals(ARG_HELP)) {
                System.out.println(helpMessage());
                System.exit(0);
            }
            if(args[i].equals(ARG_PROFILING)){
                profiling = true;
                continue;
            }
            if (args[i].equals(ARG_DISP_SEQ)) {
                dispSeq=true;
                continue;
            }
            if (args[i].equals(ARG_DISP_SEQ_STATES)) {
                dispSeq=true;
                dispSeqStates=true;
                continue;
            }
            if (args[i].equals(ARG_ENDIANNESS)) {
                endianness=true;
                continue;
            }
            if (args[i].equals(ARG_TO_BINSTRFILE)) {
                toBinStrFile=true;
                continue;
            }
            if (args[i].equals(ARG_SEQ_BINSTR)) {
                refSequence = Z2.toBooleans(args[++i]);
                continue;
            }
            if (args[i].equals(ARG_SEQ_HEXSTR)) {
                refSequence = Z2.hexBytesToPaddedBooleans(args[++i]);
                continue;
            }
            if (args[i].equals(ARG_SEQ_BINFILE)) {
                File inputFile = new File(args[++i]);
                int offset = Integer.parseInt(args[++i]);
                int length = Integer.parseInt(args[++i]);
                if(length==0) length = (int) inputFile.length();
                refSequence = Z2.binaryFileToBooleans(inputFile,offset,length);
                continue;
            }
            if (args[i].equals(ARG_SEQ_BINSTRFILE)) {
                File inputFile = new File(args[++i]);
                refSequence = Z2.binaryStringFileToBooleans(inputFile);
                continue;
            }
            if (args[i].equals(ARG_LFSR_POLY)) {
                refLfsr = Lfsr.fromPolynomial(args[++i]);
                continue;
            }
            if (args[i].equals(ARG_LFSR_BINSTR)) {
                refLfsr = Lfsr.fromBinaryString(args[++i]);
                continue;
            }
            System.out.println("Unknown argument found: "+args[i]);
            System.out.println(helpMessage());
            System.exit(1);
        }
        if(profiling){
            pauseProg("Profiling: hit enter to start the processing");
        }
        Lfsr lfsrForSeqOutput = refLfsr;
        if(null!=refSequence){

            if(null!=refLfsr) {
                System.out.println("Reference LFSR:");
                System.out.println(refLfsr.describe(dispSeq,dispSeqStates));
                if(refLfsr.getWidth()*2<=refSequence.length){
                    System.out.println("Reference sequence is long enough to unambiguously retrieve the reference LFSR");
                } else {
                    System.out.println("WARNING: Reference sequence is too short to unambiguously retrieve the reference LFSR");
                }
            }
            System.out.println("Start of the reference sequence:"+Z2.toBinaryString(refSequence,0,Math.min(64,refSequence.length)));
            Lfsr lfsr = Lfsr.fromSequence(refSequence);
            System.out.println("Reference sequence can be generated by following LFSR:");
            System.out.println(lfsr.describe(dispSeq,dispSeqStates));
            if(null!=refLfsr){
                if(refLfsr.isGeneratingSequence(refSequence)){
                    System.out.println("The reference LFSR generates the reference sequence\nInitial state: "+refLfsr.getStateString());
                }else{
                    System.out.println("The reference LFSR does not generates the reference sequence");
                }
            }
            if(endianness){
                System.out.println("\nEndianness variation of the reference sequence:");
                int maxWordSize = Math.min(refSequence.length,256);
                for(int wordSize=1;wordSize<=maxWordSize;wordSize=2*wordSize) {
                    if(refSequence.length%wordSize!=0){
                        System.out.println("Word size = "+wordSize+" skipped because it does not divides the reference sequence length ("+refSequence.length+")");
                        continue;
                    }
                    for (int atomSize = 1; atomSize <= wordSize / 2; atomSize = 2 * atomSize) {
                        System.out.println("Atom size=" + atomSize + ", Word size = " + wordSize);
                        boolean[] seq=Z2.switchEndianness(refSequence,atomSize,wordSize);
                        System.out.println("Sequence: "+Z2.toBinaryString(seq));
                        Lfsr candidate = Lfsr.fromSequence(seq);
                        System.out.println(candidate.describe(false,false));
                    }
                }
            }
            lfsrForSeqOutput = lfsr;
        }else{
            //Display the properties of the LFSR
            System.out.println(refLfsr.describe(dispSeq,dispSeqStates));
        }
        if(toBinStrFile){

        }
        if(profiling){
            System.out.println(Z2.orderOfX_callCnt);
            pauseProg("Profiling: hit enter to exit");
        }
    }
}
